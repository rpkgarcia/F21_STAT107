[["introduction-to-r-objects.html", "Chapter 2 Introduction to R Objects 2.1 Atomic Objects 2.2 Vectors 2.3 Lists 2.4 Matrices 2.5 Factors 2.6 Data Frames 2.7 Other Object Types and the Global Environment 2.8 Additional Resources", " Chapter 2 Introduction to R Objects At its core, R is an objected-oriented computational and programming environment. Everything in R is an object belonging to a certain class. In this chapter we begin by discussing atomic objects, these are the core fundamental objects used in R. Next we discuss vectors, lists, and matrices. These objects are among the most common type that are used. Lastly we discuss factors and data frames. Factors and data frames are known as dynamic objects, and are more complex. All of these objects have special properties and a multitude of features that we can use. We discuss some of their key properties here, but will continue exploring and learning about their features, and introducing more object types throughout this document. 2.1 Atomic Objects R can represent different types of data. The types include numeric, integer, complex, logical, character, and raw. These are the basic fundamental objects we can use in R. In practice raw is rarely used. For our class we will not need the complex type which stores complex numbers. Unlike other object-oriented languages we do not need to specify what type of object we are creating. Instead, R guesses the type of object you are creating. To check the object type we can use the class() function. function. Numeric Numeric objects are perhaps the most common. These are objects which contain a real number, that is, a number which can contain a decimal value. These objects are comparable to doubles in C. a = 17.45 a ## [1] 17.45 class(a) ## [1] &quot;numeric&quot; b = 5 b ## [1] 5 class(b) ## [1] &quot;numeric&quot; Both the variables a and b are numeric objects. When you type a number R will default to treating it as a numeric object which allows decimals. Integer We can also create numeric objects which are specifically made to store integer values. We can do this using the as.integer() function. a = as.integer(a) a ## [1] 17 class(a) ## [1] &quot;integer&quot; b = as.integer(b) b ## [1] 5 class(b) ## [1] &quot;integer&quot; Logical Logical values are either TRUE or FALSE and are created by using logical and relational operators. In other words, they are created by using statements that compare variables. There are several ways to do logical statements as we saw in Section 1.3. b = 5 n = (10&lt;11) n ## [1] TRUE class(n) ## [1] &quot;logical&quot; We can also assign a value as TRUE or FALSE manually by setting it equal to TRUE or FALSE, or by using T or F. c = T c ## [1] TRUE class(c) ## [1] &quot;logical&quot; Character Character values are text. They are often used as data values and labels. first = &quot;George&quot; first ## [1] &quot;George&quot; class(first) ## [1] &quot;character&quot; last = &quot;Washington&quot; last ## [1] &quot;Washington&quot; class(last) ## [1] &quot;character&quot; There are several functions that can operate on character strings. full = paste(first, last) full ## [1] &quot;George Washington&quot; nchar(full) ## [1] 17 tolower(full) ## [1] &quot;george washington&quot; toupper(full) ## [1] &quot;GEORGE WASHINGTON&quot; The function paste() concatenates two or more character strings with a separator, which is a space by default. The function nchar() returns the number of characters in a string. The functions tolower() and toupper() changes any upper case characters to lower case and vice-versa. 2.2 Vectors All the objects we have created this far are single element vectors. R is a vectorized language, meaning most of the procedures, functions, and operations have been optimized to work with vectors. It is typically advantageous to utilize this feature. A vector is a collection of values of the same data type. We can use the concatenate function, c(), to create vectors, and to make a vector larger. v1 = c(19, 390.3, pi, -32.1) v1 ## [1] 19.000000 390.300000 3.141593 -32.100000 class(v1) ## [1] &quot;numeric&quot; v2 = c(1.1, 6, -9.4, 32.1) v2 ## [1] 1.1 6.0 -9.4 32.1 class(v2) ## [1] &quot;numeric&quot; If we try to create a vector with a mix of classes R will convert all the objects to be the same class. In general, it is easiest to convert objects into a character but hard to convert character into something else. Be cautious when mixing data types and vectors because you will not be notified if objects are converted, and they may not be converted to the class you intended. v3 = c(v1, first) class(v3) ## [1] &quot;character&quot; v4 = c(first, last) class(v4) ## [1] &quot;character&quot; The length() function can be used to obtain the number of elements in a vector. length(v1) ## [1] 4 Vectors can be used in arithmetic computations. If the two vectors are of the same length, the computations are performed element-by-element. v1 + v2 ## [1] 20.100000 396.300000 -6.258407 0.000000 v1 * v2 ## [1] 20.90000 2341.80000 -29.53097 -1030.41000 Single numbers (scalars) will operate on all the vector elements in an expression. 5*v1 ## [1] 95.00000 1951.50000 15.70796 -160.50000 v1/3 ## [1] 6.333333 130.100000 1.047198 -10.700000 Individual elements of a vector can be obtained using an index in square brackets. A negative index removes that element from the vector. The v2[-1] is the vector v2 with the first element removed. The concatenate function can be used to obtain two or more elements of a vector in any desired order. Here v1[c(3,2)] returns the third and second elements of the vector v1. v1[3] ## [1] 3.141593 v2[-1] ## [1] 6.0 -9.4 32.1 v3[c(3,2)] ## [1] &quot;3.14159265358979&quot; &quot;390.3&quot; 2.3 Lists Lists are thought of as a vector with a variety of classes. A list is made up of elements, and each element can be of a different class. lst = list(4, v4, v2) lst ## [[1]] ## [1] 4 ## ## [[2]] ## [1] &quot;George&quot; &quot;Washington&quot; ## ## [[3]] ## [1] 1.1 6.0 -9.4 32.1 class(lst) ## [1] &quot;list&quot; We can observe the class of each element in the list by using the str() function. str(lst) ## List of 3 ## $ : num 4 ## $ : chr [1:2] &quot;George&quot; &quot;Washington&quot; ## $ : num [1:4] 1.1 6 -9.4 32.1 The above output tells us we have a list of three objects. The first object is a numeric vector with one element, the second object is a character vector with two elements, and third object is a numeric vector with four elements. We can subset elements in a list using double brackets we [[]]. Inside these square brakets we state the element we would like to obtain. lst[[1]] ## [1] 4 class(lst[[1]]) ## [1] &quot;numeric&quot; To determine how long our list is we can use the length() function. length(lst) ## [1] 3 2.4 Matrices A matrix is a two dimensional array of data of the same type. The matrix function, matrix(), can be used to create a new matrix. m = matrix(c(1, 9, 2, 0, 5, 7, 3, 8, 4), nrow=3, ncol=3) m ## [,1] [,2] [,3] ## [1,] 1 0 3 ## [2,] 9 5 8 ## [3,] 2 7 4 R labels the rows and columns for us in the output. The matrix is filled column-by-column using the elements of the vector created by the concatenate function. As with vectors, matrices can be used in arithmetic operations with scalars and other matrices of the same size. m2 = m/2 m2 ## [,1] [,2] [,3] ## [1,] 0.5 0.0 1.5 ## [2,] 4.5 2.5 4.0 ## [3,] 1.0 3.5 2.0 m *m2 ## [,1] [,2] [,3] ## [1,] 0.5 0.0 4.5 ## [2,] 40.5 12.5 32.0 ## [3,] 2.0 24.5 8.0 Indices can be used to obtain the elements of a matrix, but now we must consider both the row and column. m[2,2] ## [1] 5 m[c(1,3), c(1,3)] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 m[2,] ## [1] 9 5 8 m[,3] ## [1] 3 8 4 Some functions are particularly useful when using matrices. For instance, t(), dim(), and c(). The transpose function, t(), switches the column and rows of a matrix. The dimension function, dim(), returns the dimensions (number of rows, columns) of a matrix. The concatenate function, c(), turns a matrix into a vector by concatenating the columns of the matrix. # Dimensions (row, column) dim(m) ## [1] 3 3 # Transpose t(m) ## [,1] [,2] [,3] ## [1,] 1 9 2 ## [2,] 0 5 7 ## [3,] 3 8 4 # Convert to vector c(m) ## [1] 1 9 2 0 5 7 3 8 4 2.5 Factors Factors are useful for categorical data. Factors differ from character objects in that character objects is a string of characters or symbols placed in a specific order. For example, the object first = \"George\" is a character object with six elements. In contrast, the collection of values “George” would instead represent a distinct value, or level. We can create a factor object using the factor() function. colors = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;red&quot;, &quot;blue&quot;) colors = factor(colors) colors ## [1] red blue red red blue ## Levels: blue red class(colors) ## [1] &quot;factor&quot; Here the unique elements in the factor are called “levels”. There are only two levels red and blue. There are five elements in our factor object. 2.6 Data Frames Like a matrix, a data frame is a rectangular array of values where each column is a vector, However, unlike a matrix, the columns can be different data types. We can create a set of vectors of the same length and use the data.frame() function to make a data frame object. age = c(25,37,23) gender = c(&quot;Male&quot;,&quot;Male&quot;,&quot;Female&quot;) married = c(FALSE, TRUE, FALSE) friends = data.frame(age, gender, married) friends ## age gender married ## 1 25 Male FALSE ## 2 37 Male TRUE ## 3 23 Female FALSE 2.7 Other Object Types and the Global Environment There are more objects then what we have discussed above. For example, many of the advanced functions create specific objects generated by that specific function. There are hundreds, and possibly thousands, of such objects. These objects generally are special cases of lists, factors, and other various types of objects that we have defined in this section. The objects we have described here are the building blocks of most values we will be working with. Functions like class() and length() are also considered as objects, but are of a different type. We discuss functions in more detail in section 5. There are also built-in, or special objects in R. For example, the object pi is an object already defined. These built-in values and functions can be written over, but that is not advised. pi ## [1] 3.141593 Every time we create an object we see that the Global Environment tab in the top right pane updates. The object we have created is now listed in the Global Environment. This is a collection of all user created objects in R, that R knows about, and that R can easily call. Built-in objects, such as pi, will not be listed here. 2.8 Additional Resources Chapters 2, 3, 4.1, 4.3, 5.1-5.3, 6 of CRAN Intro-to-R Manual Videos: Variables 1 | Types and Assignments Variables 2 | Nameing Conventions and Best Practices Vectors 1 | Introduction Vectors 2 |Subsetting and Modifying Vectors 3 | Vectorized Functions - Logical Comparisons Matrices 1 | Introduction Matrices 2 | Accessing Rows and Columns "],["more-on-r-objects.html", "Chapter 3 More on R Objects 3.1 Factors 3.2 Lists", " Chapter 3 More on R Objects Factors and lists have especially unique properties that are often utilized. In this chapter we take special care to discuss these properties. 3.1 Factors In real-world problems, you often encounter data that can be classified in categories. For example, suppose a survey was conducted of a group of seven individuals, who were asked to identify their hair color and if they own a pet. name = c(&quot;Amy&quot;, &quot;Bob&quot;, &quot;Eve&quot;, &quot;Kim&quot;, &quot;Max&quot;, &quot;Ray&quot;, &quot;Sam&quot;) hair = c(&quot;Blonde&quot;, &quot;Black&quot;, &quot;Black&quot;, &quot;Red&quot;, &quot;Blonde&quot;, &quot;Brown&quot;, &quot;Black&quot;) own_pets = c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE) catagorical = data.frame(name, hair, own_pets) colnames(catagorical) = c(&quot;Name&quot;, &quot;Hair Color&quot;, &quot;Own Pets&quot;) catagorical ## Name Hair Color Own Pets ## 1 Amy Blonde TRUE ## 2 Bob Black FALSE ## 3 Eve Black TRUE ## 4 Kim Red TRUE ## 5 Max Blonde FALSE ## 6 Ray Brown FALSE ## 7 Sam Black FALSE Here, the hair color and gender are the examples of categorical data. To store such categorical data, R has a special data structure called factors. A factor is an ordered collection of items. The different values that the factor can take are called levels. In R, you can create a factor with the factor() function. f = factor(hair) f ## [1] Blonde Black Black Red Blonde Brown Black ## Levels: Black Blonde Brown Red A factor looks like a vector, but it has special properties. Levels are one of them. Notice that when you print the factor, R displays the distinct levels below the factor. R keeps track of all the possible values in a vector, and each value is called a level of the associated factor.The levels() function shows all the levels from a factor. gender = c(&quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;) f = factor(gender) levels(f) ## [1] &quot;Female&quot; &quot;Male&quot; f ## [1] Female Male Female Female Male Male Male ## Levels: Female Male If your vector contains only a subset of all the possible levels, then R will have an incomplete picture of the possible levels. Consider the following example of a vector consisting of directions: directions = c(&quot;North&quot;, &quot;West&quot;, &quot;North&quot;, &quot;East&quot;, &quot;North&quot;, &quot;West&quot;, &quot;East&quot;) f = factor(directions) f ## [1] North West North East North West East ## Levels: East North West Notice that the levels of your new factor do not contain the value “South”. So, R thinks that North, West, and East are the only possible levels. However, in practice, it makes sense to have all the possible directions as levels of your factor. To add all the possible levels explicitly, you specify the levels argument of the function factor(). directions = c(&quot;North&quot;, &quot;West&quot;, &quot;North&quot;, &quot;East&quot;, &quot;North&quot;, &quot;West&quot;, &quot;East&quot;) f = factor(directions, levels = c(&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;)) f ## [1] North West North East North West East ## Levels: North East South West R lets you assign abbreviated names for the levels. You can do this by specifying the labels argument of factor(). directions = c(&quot;North&quot;, &quot;West&quot;, &quot;South&quot;, &quot;East&quot;, &quot;West&quot;, &quot;North&quot;, &quot;South&quot;) f = factor(directions, levels = c(&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;), labels = c(&quot;N&quot;, &quot;E&quot;, &quot;S&quot;, &quot;W&quot;)) f ## [1] N W S E W N S ## Levels: N E S W Sometimes data has some kind of natural order between elements. For example, sports analysts use a three-point scale to determine how well a sports team is competing: loss &lt; tie &lt; win. In market research, it’s very common to use a five point scale to measure perceptions: strongly disagree &lt; disagree &lt; neutral &lt; agree &lt; strongly agree. Such kind of data that is possible to place in order or scale is known as Ordinal data. In R, there is a special data type for ordinal data. This type is called ordered factors. To create an ordered factor, use the factor() function with the argument ordered=TRUE. record = c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;win&quot;) f = factor(record, ordered = TRUE) f ## [1] win tie loss tie loss win win ## Levels: loss &lt; tie &lt; win You can also reverse the order of levels using the rev() function. record = c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;win&quot;) f = factor(record, ordered = TRUE, levels = rev(levels(f))) f ## [1] win tie loss tie loss win win ## Levels: win &lt; tie &lt; loss If you have no observations in one of the levels, you can drop it using the droplevels() function. record = c(&quot;win&quot;, &quot;loss&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;loss&quot;, &quot;win&quot;) f = factor(record, levels = c(&quot;loss&quot;, &quot;tie&quot;, &quot;win&quot;)) f ## [1] win loss loss win loss win ## Levels: loss tie win droplevels(f) ## [1] win loss loss win loss win ## Levels: loss win The summary() function will give you a quick overview of the contents of a factor. f = factor(hair) f ## [1] Blonde Black Black Red Blonde Brown Black ## Levels: Black Blonde Brown Red summary(f) ## Black Blonde Brown Red ## 3 2 1 1 The function table() tabulates observations. table(f) ## f ## Black Blonde Brown Red ## 3 2 1 1 3.2 Lists A list is an array of objects. Unlike vectors and matrices, the objects can belong to different classes. Lists are useful for packaging together a set of related objects. We can create a list of objects in our environment by using the list() function. lst = list(1, 2, 3) # A list of characters lst = list(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) # A list of mixed datatypes lst = list(1, &quot;abc&quot;, 1.23, TRUE) The best way to understand the contents of a list is to use the structure function str(). It provides a compact display of the internal structure of a list. lst = list(1, &quot;abc&quot;, 1.23, TRUE) str(lst) ## List of 4 ## $ : num 1 ## $ : chr &quot;abc&quot; ## $ : num 1.23 ## $ : logi TRUE A list can contain sublists, which in turn can contain sublists themselves, and so on. This is known as nested list or recursive vectors. lst = list(1, 3, &quot;abc&quot;, list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), TRUE) str(lst) ## List of 5 ## $ : num 1 ## $ : num 3 ## $ : chr &quot;abc&quot; ## $ :List of 3 ## ..$ : chr &quot;a&quot; ## ..$ : chr &quot;b&quot; ## ..$ : chr &quot;c&quot; ## $ : logi TRUE There are two ways to extract elements from a list: Using [[]] gives you the element itself. Using [] gives you a list with the selected elements You can use [] to extract either a single element or multiple elements from a list. However, the result will always be a list. # extract 2nd element lst[2] ## [[1]] ## [1] 3 # extract 5th element lst[5] ## [[1]] ## [1] TRUE # select 1st, 3rd and 5th element lst[c(1,3,5)] ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;abc&quot; ## ## [[3]] ## [1] TRUE # exclude 1st, 3rd and 5th element lst[c(-1,-3,-5)] ## [[1]] ## [1] 3 ## ## [[2]] ## [[2]][[1]] ## [1] &quot;a&quot; ## ## [[2]][[2]] ## [1] &quot;b&quot; ## ## [[2]][[3]] ## [1] &quot;c&quot; You can use [[]] to extract only a single element from a list. Unlike [], [[]] gives you the element itself. # extract 2nd element lst[[2]] ## [1] 3 # extract 5th element lst[[5]] ## [1] TRUE You can’t use logical vectors or negative numbers as indices when using [[]]. The difference between [] and [[]] is really important for lists, because [[]] returns the element itself while [] returns a list with the selected elements. The difference becomes clear when we inspect the structure of the output – one is a character and the other one is a list. lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) class(lst[[1]]) ## [1] &quot;character&quot; class(lst[1]) ## [1] &quot;list&quot; Each list element can have a name. You can access individual element by specifying its name in double square brackets [[]] or use $ operator. months = list(JAN=1, FEB=2, MAR=3, APR=4) # extract element by its name months[[&quot;MAR&quot;]] ## [1] 3 # same as above but using the $ operator months$MAR ## [1] 3 # extract multiple elements months[c(&quot;JAN&quot;,&quot;APR&quot;)] ## $JAN ## [1] 1 ## ## $APR ## [1] 4 You can access individual items in a nested list by using the combination of [[]] or $ operator and the [] operator. lst = list(item1 = 3.14, item2 = list(item2a = 5:10, item2b = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;))) # preserve the output as a list lst[[2]][1] ## $item2a ## [1] 5 6 7 8 9 10 # same as above but simplify the output lst[[2]][[1]] ## [1] 5 6 7 8 9 10 # same as above with names lst[[&quot;item2&quot;]][[&quot;item2a&quot;]] ## [1] 5 6 7 8 9 10 # same as above with $ operator lst$item2$item2a ## [1] 5 6 7 8 9 10 # extract individual element lst[[2]][[2]][3] ## [1] &quot;c&quot; Modifying a list element is pretty straightforward. You use either the [[]] or the $ to access that element, and simply assign a new value. # Modify 3rd list element lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) lst[[3]] = 1 str(lst) ## List of 6 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : num 1 ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; ## $ : chr &quot;f&quot; You can modify components using [] as well, but you have to assign a list of components. # Modify 3rd list element using [] lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) lst[3] = list(1) str(lst) ## List of 6 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : num 1 ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; ## $ : chr &quot;f&quot; Using [] allows you to modify more than one component at once. # Modify first three list elements lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) lst[1:3] = list(1,2,3) str(lst) ## List of 6 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; ## $ : chr &quot;f&quot; You can use same method for modifying elements and adding new one. If the element is already present in the list, it is updated else, a new element is added to the list. # Add elements to a list lst = list(1, 2, 3) lst[[4]] = 4 str(lst) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 By using append() method you can append one or more elements to the list. # Add more than one element to a list lst = list(1, 2, 3) lst = append(lst,c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) str(lst) ## List of 6 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : chr &quot;c&quot; To remove a list element, select it by position or by name, and then assign NULL to it. # Remove element from list lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) lst[[3]] = NULL str(lst) ## List of 4 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; Using [], you can delete more than one component at once. # Remove multiple elements at once lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) lst[1:4] = NULL str(lst) ## List of 1 ## $ : chr &quot;e&quot; By using a logical vector, you can remove list elements based on the condition. # Remove all negative list elements lst = list(-4,-3,-2,-1,0,1,2,3,4) lst[lst &lt;= 0] = NULL str(lst) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 The c() does a lot more than just creating vectors. It can be used to combine lists into a new list as well. lst1 = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) lst2 = list(1,2,3) lst = c(lst1, lst2) str(lst) ## List of 6 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : chr &quot;c&quot; ## $ : num 1 ## $ : num 2 ## $ : num 3 Basic statistical functions work on vectors but not on lists. For example, you cannot directly compute the mean of list of numbers. In that case, you have to flatten the list into a vector using unlist() first and then compute the mean of the result. lst = list(5, 10, 15, 20, 25) mean(unlist(lst)) ## [1] 15 To find the length of a list, use length() function. length(lst) ## [1] 5 "]]
