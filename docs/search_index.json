[["regular-expressions.html", "Chapter 11 Regular Expressions 11.1 Ranges, Escaping 11.2 Metacharacters 11.3 Quantifiers 11.4 Anchoring 11.5 Splitting on a Regexp 11.6 An Example Additional Resources", " Chapter 11 Regular Expressions With basic string-manipulation functions, we saw how to do things like split up entries in a data file which are separated by commas. text = &quot;One Fish, Two Fish, Red Fish, Blue Fish&quot; strsplit(text,split=&quot;,&quot;) ## [[1]] ## [1] &quot;One Fish&quot; &quot; Two Fish&quot; &quot; Red Fish&quot; &quot; Blue Fish&quot; or by single spaces strsplit(text,split=&quot; &quot;) ## [[1]] ## [1] &quot;One&quot; &quot;Fish,&quot; &quot;Two&quot; &quot;Fish,&quot; &quot;Red&quot; &quot;Fish,&quot; &quot;Blue&quot; &quot;Fish&quot; or even a comma followed by a space strsplit(text,split=&quot;, &quot;) ## [[1]] ## [1] &quot;One Fish&quot; &quot;Two Fish&quot; &quot;Red Fish&quot; &quot;Blue Fish&quot; But we don’t know how to deal with situations like splitting on a comma, optionally followed by some number of spaces. Not only is it annoying to have such a simple thing defeat us, it’s an instance of a much broader class of problems. If we’re trying to extract data from webpages, we may want to get rid of all the formatting instructions buried in the source of the webpage. We might want to extract all the personal names from a document which are preceded by titles (such as Mr., Ms., Miss, Dr.), without knowing what those names are, or how long they are. And so forth. We need a language for telling R about patterns of strings. The most basic such language is that of regular expressions. Regular expressions are used to match sets of strings. Start with string constants, and build up by allowing “this and then that”, “either this or that”, “repeat this”, etc. These rules get expressed in a grammar, with special symbols. Every regular expression is a sequence of symbols, which specifies a set of text strings that follow some pattern that — match the regular expression. - Regular expressions are strings and therefore a regexp can be stored in a character variable. This means that regexps can be built up and changed using string-manipulating functions. A valid regular expression must conform to certain rules of grammar; it gets interpreted by the computer as rules for matching certain strings, but not others. Every string is a valid regexp. We say “regexp” as short hand for the phrase a “regular expression as used in R”. fly matches end of “fruitfly”, “why walk when you can fly” but it does not match “time flies like an arrow; fruit flies like a banana; a banana flies poorly”. fly_phrases = c(&quot;fruitfly&quot;, &quot;why walk when you can fly&quot;, &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot;, &quot;superman flew&quot;) # Returns which elements have the term &quot;fly&quot; grep(&quot;fly&quot;, fly_phrases, value = T) ## [1] &quot;fruitfly&quot; &quot;why walk when you can fly&quot; If we did wish to match one regexp OR another regexp we cold use the “|” symbol. This symbol is used in the same way it was in section 1.4 # Returns which elements have the term &quot;fly&quot; or &quot;flies&quot; grep(&quot;fly|flies&quot;, fly_phrases, value = T) ## [1] &quot;fruitfly&quot; ## [2] &quot;why walk when you can fly&quot; ## [3] &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot; # Returns which elements have the term &quot;fly&quot; or &quot;flies&quot; grep(&quot;flies|fly&quot;, fly_phrases, value = T) ## [1] &quot;fruitfly&quot; ## [2] &quot;why walk when you can fly&quot; ## [3] &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot; # Returns which elements have &quot;fly flies&quot; or &quot;time&quot; or &quot;flies&quot; grep(&quot;time|fruit fly|flies&quot;, fly_phrases, value = T) ## [1] &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot; Parentheses are used to create groups. text_colors = c(&quot;Some people say grey&quot;, &quot;others say gray,&quot;, &quot;and both are greatly used&quot;) # Searches for the same thing grep(&quot;gr(e|a)y&quot;, text_colors, value = T) ## [1] &quot;Some people say grey&quot; &quot;others say gray,&quot; grep(&quot;grey|gray&quot;, text_colors, value = T) ## [1] &quot;Some people say grey&quot; &quot;others say gray,&quot; 11.1 Ranges, Escaping A character class is a list of characters enclosed between [ and ] which matches any single character in that list. We use these braces in regular expressions to indicate character ranges. For example the regexp [0123456789] matches any single digit. text = c(&quot;1 Fish&quot;, &quot;2 Fish&quot;, &quot;red fish&quot;, &quot;blue fish&quot;) # Any numbers? grep(&quot;[0123456789]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; If the first character of the list is the caret ^, then it matches any character not in the list. For example, [^abc] matches anything except the characters a, b or c. # Any letters EXCEPT a, b, c grep(&quot;[^abc]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; &quot;red fish&quot; &quot;blue fish&quot; Another example: t[aeiou] matches any two-character sequence in which “t” is followed by a lowercase vowel. text_baseball = c(&quot;Ohhhhh&quot;, &quot;take me out&quot;, &quot;to the ball game&quot;) # Match any two-character sequence in which “t” is followed by a lowercase vowel. grep(&quot;t[aeiou]&quot;,text_baseball, value = T) ## [1] &quot;take me out&quot; &quot;to the ball game&quot; This system of using ranges is used a lot, and there are certain named classes of characters are predefined, below are some of them. [:lower:] : Lower-case letters, equivalent to [a-z] [:upper:] : Upper-case letters, equivalent to [A-Z] [:alpha:] : Alphabetic characters: [:lower:] and [:upper:]. [:digit:] : Digits: 0 1 2 3 4 5 6 7 8 9, equivalent to [0-9] \\d : digit, equivalent to [:digit:] \\D : Non-digit [:alnum:] : Alphanumeric characters: [:alpha:] and [:digit:]. [:blank:] : Blank characters: space and tab, and possibly other locale-dependent characters such as non-breaking space. [:punct:] : Punctuation characters: ! \" # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~. [:graph:] : Graphical characters: [:alnum:] and [:punct:]. [:space:] : Space characters: tab, newline, vertical tab, form feed, carriage return, space and possibly other locale-dependent characters. \\s : space \\S : not space \\w: word characters, equivalent to [[:alnum:]_] or [A-z0-9]. \\W: not word, equivalent to [^A-z0-9_]. # Are any digits in the text? grep(&quot;[[:digit:]]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; # Are any upper case letters in the text? grep(&quot;[[:upper:]]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; # Are any lower case letters in the text? grep(&quot;[[:lower:]]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; &quot;red fish&quot; &quot;blue fish&quot; 11.2 Metacharacters The fundamental building blocks are the regular expressions that match a single character. Most characters, including all letters and digits, are regular expressions that match themselves. However, we also use some of these characters to mean different things in order to match more intricate patterns. The characters reserved for special meanings (and not simply as characters to match) are called metacharacters. Any metacharacter with special meaning may be quoted by preceding it with a backslash. The metacharacters in extended regular expressions are . | ( ) [ { ^ $ * + ?. We already saw | and [] in action above. Now lets talk about the . symbol. This symbol matches any single character. To match strings that have a “.” we need to use a backslash. text = c(&quot;There was a monster&quot;, &quot;Superman flew over there.&quot;, &quot;He made it in time.&quot;, &quot;Yumm, pancakes!&quot;, &quot;MMmm Mmmm they were good...&quot;) # Looks for every character grep(&quot;.&quot;, text, value = T) ## [1] &quot;There was a monster&quot; &quot;Superman flew over there.&quot; ## [3] &quot;He made it in time.&quot; &quot;Yumm, pancakes!&quot; ## [5] &quot;MMmm Mmmm they were good...&quot; # Matches only &quot;.&quot; grep(&quot;\\\\.&quot;, text, value = T) ## [1] &quot;Superman flew over there.&quot; &quot;He made it in time.&quot; ## [3] &quot;MMmm Mmmm they were good...&quot; 11.3 Quantifiers Here is a list of some of the metacharacters and some of their features. These are all quantifiers and they control how many times the regexp should be matched. The following features all are considered repetition quantifiers. + : The preceding item will be matched one or more times. * : The preceding item will be matched zero or more times. ? : The preceding item is optional and will be matched at most once. {n} : The preceding item is matched exactly “n” times. {n,} : The preceding item is matched “n” or more times. {n,m} : The preceding item is matched at least “n” times, but not more than “m” times. # Detect the letter &quot;m&quot; grep(&quot;m&quot;, text, value = T) ## [1] &quot;There was a monster&quot; &quot;Superman flew over there.&quot; ## [3] &quot;He made it in time.&quot; &quot;Yumm, pancakes!&quot; ## [5] &quot;MMmm Mmmm they were good...&quot; # Detect the letter &quot;m&quot; exactly one time grep(&quot;m{1}&quot;, text, value = T) ## [1] &quot;There was a monster&quot; &quot;Superman flew over there.&quot; ## [3] &quot;He made it in time.&quot; &quot;Yumm, pancakes!&quot; ## [5] &quot;MMmm Mmmm they were good...&quot; If we want to match a regexp exactly {n}, {n,} or {n,m} times then it looks for this sequence consecutively. For example, the following command does not output “He made it in time.”, despite this phrase having two “m”s in it. # Detect the letter &quot;m&quot; exactly two or more times (in a row) grep(&quot;m{2,}&quot;, text, value = T) ## [1] &quot;Yumm, pancakes!&quot; &quot;MMmm Mmmm they were good...&quot; # Another example text = c(&quot;3, 2, 1, GO!&quot;, &quot;On the count of 3,&quot;, &quot;Count to 100&quot;, &quot;Wish upon 1 star.&quot;) # Detect exactly two digits in a row. grep(&quot;[[:digit:]]{2}&quot;, text, value = T) ## [1] &quot;Count to 100&quot; By default, quantifiers are “greedy” and they match as many repetitions as they can. Following a quantifier by ? makes it match as few as possible. # Only look for one digit then stop. # It doesn&#39;t matter if there is more. grep(&quot;[[:digit:]]?&quot;, text, value = T) ## [1] &quot;3, 2, 1, GO!&quot; &quot;On the count of 3,&quot; &quot;Count to 100&quot; ## [4] &quot;Wish upon 1 star.&quot; 11.4 Anchoring Anchoring is used to find regexps at specific locations in a string. For example, at the beginning or end of a word, or at the beginning or end of a phrase. $ means a pattern can only match at the end of a line or string ^ means (outside of braces) the beginning of a line or string &lt; and &gt; anchor to beginning or ending of words \\b anchors boundary (beginning or ending) of words, \\B anywhere else # matches elements ending in a lower-case letter or comma grep(&quot;[a-z,]$&quot;, text, value = T) ## [1] &quot;On the count of 3,&quot; # matches capital letters not at the beginning or ending of a word grep(&quot;\\\\B[A-Z]&quot;, text, value = T) ## [1] &quot;3, 2, 1, GO!&quot; # Find elements that end with a number grep(&quot;[[:digit:]]$&quot;, text, value = T) ## [1] &quot;Count to 100&quot; # Find elements that start with a number grep(&quot;^[[:digit:]]&quot;, text, value = T) ## [1] &quot;3, 2, 1, GO!&quot; # Find elements that have a word that starts or ends with u grep(&quot;\\\\bu&quot;, text, value = T) ## [1] &quot;Wish upon 1 star.&quot; # Find elements that have a word that starts or ends with t grep(&quot;\\\\bt&quot;, text, value = T) ## [1] &quot;On the count of 3,&quot; &quot;Count to 100&quot; 11.5 Splitting on a Regexp We can use regexps in many R functions, we are not limited to just grep() and grepl. For example, strsplit() will take a regexp as its split argument. This means we can make splits a string into new strings at each instance of the regexp, just like it would if split were a string. # Load data: al2 = readLines(&quot;http://www.stat.cmu.edu/~cshalizi/statcomp/14/lectures/04/al2.txt&quot;) al2 = paste(al2, collapse=&quot; &quot;) # Split words by space al2.words1 = strsplit(al2, split=&quot; &quot;) # Lets see what this looks like head(sort(table(al2.words1))) ## al2.words1 ## - &quot;the &quot;Woe absorbs accept achieve ## 1 1 1 1 1 1 # Split words by space or by a punctuation symbol al2.words2 = strsplit(al2, split=&quot;(\\\\s|[[:punct:]])+&quot;)[[1]] head(sort(table(al2.words2))) ## al2.words2 ## absorbs accept achieve against agents aid ## 1 1 1 1 1 1 Closer examination shows there’s still a problem: “men’s” \\(\\rightarrow\\) “men”, “s”. To handle possessives: look for any number of white spaces, or at least one punctuation mark followed by at least one space al2.words3 = strsplit(al2, split=&quot;\\\\s+|([[:punct:]]+[[:space:]]+)&quot;)[[1]] head(sort(table(al2.words3))) ## al2.words3 ## &quot;the &quot;Woe absorbs accept achieve ## 1 1 1 1 1 1 11.6 An Example grep() scans a character vector for matches to a regexp returns either indices of matches, or matching strings grep(x, pattern, value) Example: scanning data files ANSS.csv.html catalogs earthquakes of magnitude 6+, 1/1/2002–1/1/2012 &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;NCEDC_Search_Results&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;Your search parameters are:&lt;ul&gt; &lt;li&gt;catalog=ANSS &lt;li&gt;start_time=2002/01/01,00:00:00 &lt;li&gt;end_time=2012/01/01,00:00:00 &lt;li&gt;minimum_magnitude=6.0 &lt;li&gt;maximum_magnitude=10 &lt;li&gt;event_type=E &lt;/ul&gt; &lt;PRE&gt; DateTime,Latitude,Longitude,Depth,Magnitude,MagType,NbStations,Gap,Distance,RMS,Source,EventID 2002/01/01 10:39:06.82,-55.2140,-129.0000,10.00,6.00,Mw,78,,,1.07,NEI,2002010140 Now we work on extracting just the data, not the search parameters and so forth. Notice that every line of data begins with a date, YYYY/MM/DD. We can use this to find just the part of the data that we want. anss = readLines(&quot;http://www.stat.cmu.edu/~cshalizi/statcomp/14/lectures/05/ANSS.csv.html&quot;, warn=FALSE) initial_date = &quot;^[0-9]{4}/[0-9]{2}/[0-9]{2}&quot; head(grep(x=anss,pattern=initial_date,value=TRUE)) ## [1] &quot;2002/01/01 10:39:06.82,-55.2140,-129.0000,10.00,6.00,Mw,78,,,1.07,NEI,2002010140&quot; ## [2] &quot;2002/01/01 11:29:22.73,6.3030,125.6500,138.10,6.30,Mw,236,,,0.90,NEI,2002010140&quot; ## [3] &quot;2002/01/02 14:50:33.49,-17.9830,178.7440,665.80,6.20,Mw,215,,,1.08,NEI,2002010240&quot; ## [4] &quot;2002/01/02 17:22:48.76,-17.6000,167.8560,21.00,7.20,Mw,427,,,0.90,NEI,2002010240&quot; ## [5] &quot;2002/01/03 07:05:27.67,36.0880,70.6870,129.30,6.20,Mw,431,,,0.87,NEI,2002010340&quot; ## [6] &quot;2002/01/03 10:17:36.30,-17.6640,168.0040,10.00,6.60,Mw,386,,,1.14,NEI,2002010340&quot; We can also use the invert option to find the non-matches. grep(x=anss,pattern=initial_date,invert=TRUE,value=TRUE) ## [1] &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;NCEDC_Search_Results&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;Your search parameters are:&lt;ul&gt;&quot; ## [2] &quot;&lt;li&gt;catalog=ANSS&quot; ## [3] &quot;&lt;li&gt;start_time=2002/01/01,00:00:00&quot; ## [4] &quot;&lt;li&gt;end_time=2012/01/01,00:00:00&quot; ## [5] &quot;&lt;li&gt;minimum_magnitude=6.0&quot; ## [6] &quot;&lt;li&gt;maximum_magnitude=10&quot; ## [7] &quot;&lt;li&gt;event_type=E&quot; ## [8] &quot;&lt;/ul&gt;&quot; ## [9] &quot;&lt;PRE&gt;&quot; ## [10] &quot;DateTime,Latitude,Longitude,Depth,Magnitude,MagType,NbStations,Gap,Distance,RMS,Source,EventID&quot; ## [11] &quot;&lt;/PRE&gt;&quot; ## [12] &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot; 11.6.1 Match Locations and Substrings When you just want a Boolean vector saying where the matches are use grepl(). grepl(x=anss,pattern=initial_date)[1:20] ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can also consider the function regexpr() which returns location of first match in the target string, plus attributes like length of matching substring. The function gregexpr() is similar, but it returns a list of this for all matches. A location of -1 means no match, and neither returns the text of the match x = c(&quot;A and B&quot;, &quot;A, B and C&quot;, &quot;A, B, C and D&quot;, &quot;foobar&quot;) pattern = &quot;[[:space:]]*(,|and)[[:space:]]&quot; # Match data from regexpr() regexpr(pattern, x) ## [1] 2 2 2 -1 ## attr(,&quot;match.length&quot;) ## [1] 5 2 2 -1 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE # Match data from gregexpr() gregexpr(pattern, x) ## [[1]] ## [1] 2 ## attr(,&quot;match.length&quot;) ## [1] 5 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE ## ## [[2]] ## [1] 2 5 ## attr(,&quot;match.length&quot;) ## [1] 2 5 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE ## ## [[3]] ## [1] 2 5 8 ## attr(,&quot;match.length&quot;) ## [1] 2 2 5 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE ## ## [[4]] ## [1] -1 ## attr(,&quot;match.length&quot;) ## [1] -1 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE To getting the matching text we can use regmatches() which takes the output of regexpr() or gregexpr() and a string, and returns the matching strings. x = c(&quot;A and B&quot;, &quot;A, B and C&quot;, &quot;A, B, C and D&quot;, &quot;foobar&quot;) pattern = &quot;[[:space:]]*(,|and)[[:space:]]&quot; ## Match data from regexpr() m = regexpr(pattern, x) regmatches(x, m) ## [1] &quot; and &quot; &quot;, &quot; &quot;, &quot; regmatches(x, m, invert = TRUE) ## [[1]] ## [1] &quot;A&quot; &quot;B&quot; ## ## [[2]] ## [1] &quot;A&quot; &quot;B and C&quot; ## ## [[3]] ## [1] &quot;A&quot; &quot;B, C and D&quot; ## ## [[4]] ## [1] &quot;foobar&quot; ## Match data from gregexpr() m = gregexpr(pattern, x) regmatches(x, m) ## [[1]] ## [1] &quot; and &quot; ## ## [[2]] ## [1] &quot;, &quot; &quot; and &quot; ## ## [[3]] ## [1] &quot;, &quot; &quot;, &quot; &quot; and &quot; ## ## [[4]] ## character(0) regmatches(x, m, invert = TRUE) ## [[1]] ## [1] &quot;A&quot; &quot;B&quot; ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## [[3]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ## ## [[4]] ## [1] &quot;foobar&quot; Why separate regexpr() from regmatches? This lets us do things like count the number or length of matches with less work. It also lets us see what text in one file corresponds to matching locations in another file. Get the (latitude, longitude) pair for each earthquake. one_geo_coord = paste(&quot;-?[0-9]+\\\\.[0-9]{4}&quot;) pair_geo_coords = paste(rep(one_geo_coord,2),collapse=&quot;,&quot;) have_coords = grepl(x=anss,pattern=pair_geo_coords) coord.matches = gregexpr(pattern=pair_geo_coords,text=anss[have_coords]) coords = regmatches(x=anss[have_coords],m=coord.matches) head(coords) ## [[1]] ## [1] &quot;-55.2140,-129.0000&quot; ## ## [[2]] ## [1] &quot;6.3030,125.6500&quot; ## ## [[3]] ## [1] &quot;-17.9830,178.7440&quot; ## ## [[4]] ## [1] &quot;-17.6000,167.8560&quot; ## ## [[5]] ## [1] &quot;36.0880,70.6870&quot; ## ## [[6]] ## [1] &quot;-17.6640,168.0040&quot; coord.matches[1] ## [[1]] ## [1] 24 ## attr(,&quot;match.length&quot;) ## [1] 18 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE coords =unlist(coords) # De-list-ify to vector coord.pairs = strsplit(coords,&quot;,&quot;) # Break apart latitude and longitude coord.df = do.call(rbind, coord.pairs) # De-list-ify to array coord.df = apply(coord.df,2,as.numeric) # Character to numeric coord.df = as.data.frame(coord.df) colnames(coord.df) = c(&quot;Latitude&quot;,&quot;Longitude&quot;) head(coord.df) ## Latitude Longitude ## 1 -55.214 -129.000 ## 2 6.303 125.650 ## 3 -17.983 178.744 ## 4 -17.600 167.856 ## 5 36.088 70.687 ## 6 -17.664 168.004 library(maps) ## Warning: package &#39;maps&#39; was built under R version 4.0.2 map(&quot;world&quot;) points(x=coord.df$Longitude, y=coord.df$Latitude, pch=19, col=&quot;red&quot;) 11.6.2 Replacements Assigning to regmatches() changes the matched string, just like substr() sub() and gsub() work like regexpr() and gregexpr(), but with an extra replace argument sub() produces a new string, assigning to regmatches() modifies the original one Really, assigning to regmatches() creates a new string, destroys the old one, and assigns the new string the old name. Additional Resources “Begining Computer Science with R” Chapter 12 R Help Page on Regular Expressions "]]
