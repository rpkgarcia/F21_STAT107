[["apply.html", "Chapter 9 Apply Family of Functions 9.1 apply() 9.2 lapply() 9.3 sapply() 9.4 tapply() 9.5 mapply() 9.6 replicate() 9.7 How to Pick a Method 9.8 More Examples Additional Resources", " Chapter 9 Apply Family of Functions Loops (like for, and while) are a way to repeatedly execute some code. However, they are often slow in execution when it comes to processing large data sets. R has a more efficient and quick approach to perform iterations – The apply family. The apply family consists of vectorized functions. Below are the most common forms of apply functions. apply() lapply() sapply() tapply() mapply() replicate() These functions let you take data in batches and process the whole batch at once. There primary difference is in the object (such as list, matrix, data frame etc.) on which the function is applied to and the object that will be returned from the function. These functions apply a function to different components of a vector/list/dataframe/array in a non-sequential way. In general, if each element in your object is not dependent on the other elements of your object then an apply function is usually faster than a loop. 9.1 apply() The apply()function is used to apply a function to the rows or columns of matrices or data frames. It assembles the returned values into a vector, and then returns that vector. If you want to apply a function on a data frame, make sure that the data frame is homogeneous (i.e. either all numeric values or all character strings) Otherwise, R will force all columns to have identical types. This may not be what you want. In that case, use the lapply() or sapply() functions. Description of the required apply() arguments: X: A matrix , data frame or array MARGIN: A vector giving the subscripts which the function will be applied over. 1 indicates rows 2 indicates columns c(1, 2) indicates rows and columns FUN: The function to be applied # Get column means data = matrix(1:9, nrow=3, ncol=3) data ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 apply(data, 2, mean) ## [1] 2 5 8 # Get row means apply(data, 1, sum) ## [1] 12 15 18 You can use user-defined functions as well. apply(data, 2, function(x){ # Standard deviation formula y = sum(x -mean(x))^2/(length(x)-1) return(y) }) ## [1] 0 0 0 9.2 lapply() The lapply() function is used to apply a function to each element of the list. It collects the returned values into a list, and then returns that list. Description of the required lapply() arguments: X: A matrix , data frame or array FUN: The function to be applied data_lst = list(item1 = 1:5, item2 = seq(4,36,8), item3 = c(1,3,5,7,9)) data_lst ## $item1 ## [1] 1 2 3 4 5 ## ## $item2 ## [1] 4 12 20 28 36 ## ## $item3 ## [1] 1 3 5 7 9 data_vector = c(1,2,3,4,5,6,7,8) data_vector ## [1] 1 2 3 4 5 6 7 8 lapply(data_lst, sum) ## $item1 ## [1] 15 ## ## $item2 ## [1] 100 ## ## $item3 ## [1] 25 lapply(data_vector, sum) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 9.3 sapply() The sapply() and lapply() work basically the same. The only difference is that lapply() always returns a list, whereas sapply() tries to simplify the result into a vector or matrix. If the return value is a list where every element is length 1, you get a vector. If the return value is a list where every element is a vector of the same length (&gt; 1), you get a matrix. If the lengths vary, simplification is impossible and you get a list. Description of the required sapply() arguments: X: A matrix , data frame or array FUN: The function to be applied data_lst = list(item1 = 1:5, item2 = seq(4,36,8), item3 = c(1,3,5,7,9)) data_lst ## $item1 ## [1] 1 2 3 4 5 ## ## $item2 ## [1] 4 12 20 28 36 ## ## $item3 ## [1] 1 3 5 7 9 sapply(data_lst, sum) ## item1 item2 item3 ## 15 100 25 9.4 tapply() The tapply() function breaks the data set up into groups and applies a function to each group. Description of the required sapply() arguments: X: A matrix , data frame or array INDEX: A grouping factor or a list of factors FUN: The function to be applied data = data.frame(name=c(&quot;Amy&quot;,&quot;Max&quot;,&quot;Ray&quot;,&quot;Kim&quot;,&quot;Sam&quot;,&quot;Eve&quot;,&quot;Bob&quot;), age=c(24, 22, 21, 23, 20, 24, 21), gender=factor(c(&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;))) data ## name age gender ## 1 Amy 24 F ## 2 Max 22 M ## 3 Ray 21 M ## 4 Kim 23 F ## 5 Sam 20 M ## 6 Eve 24 F ## 7 Bob 21 M tapply(data$age, data$gender, min) ## F M ## 23 20 9.5 mapply() The mapply() function is a multivariate version of sapply(). It applies FUN to the first elements of each … argument, the second elements, the third elements, and so on. Description of the required mapply() arguments: FUN: The function to be applied ...: Arguments to vectorize over (vectors or lists of strictly positive length, or all of zero length). mapply(rep, times = 1:4, x = 4:1) ## [[1]] ## [1] 4 ## ## [[2]] ## [1] 3 3 ## ## [[3]] ## [1] 2 2 2 ## ## [[4]] ## [1] 1 1 1 1 9.6 replicate() The replicate() function is a wrapper for sapply(). If we want to repeat an evaluation of an function call or an expression that does not require us to iterate through a data set or vector we can use replicate(). Description of the required replicate() arguments: n: An integer containing the number of replications. expr: The expression (or function call) to evaluate repeatedly. replicate(n = 4, &quot;Hello&quot;) ## [1] &quot;Hello&quot; &quot;Hello&quot; &quot;Hello&quot; &quot;Hello&quot; replicate(n = 10, factorial(4)) ## [1] 24 24 24 24 24 24 24 24 24 24 replicate(n = 5, sample(c(&quot;red&quot;, &quot;blue&quot;))) ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;red&quot; &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; ## [2,] &quot;blue&quot; &quot;red&quot; &quot;red&quot; &quot;blue&quot; &quot;blue&quot; 9.7 How to Pick a Method It can be difficult at first to decide which of these apply function you may want to use. In general, we can use the flow chart below as a quick guide. 9.8 More Examples To see some more examples of these functions in action. We will use the iris data set which is a built in data set in R. This data set has four numeric columns, and one factor column, Species. Each row is a flower, and there are four different measurements of each flower. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Find the maximum value for the numeric variables for each observation. numeric_iris = iris[,-5] max_in_row = apply(numeric_iris, 1, max) head(max_in_row) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 Determine the (arithmetic) mean of the sepal width for each species. mean_species = tapply(iris$Sepal.Width, INDEX = iris$Species, mean) mean_species ## setosa versicolor virginica ## 3.428 2.770 2.974 Determine the (arithmetic) mean and the median of sepal width for each species. my_avgs = function(vec){ the_mean = mean(vec) the_median = median(vec) return_object=c(the_mean, the_median) names(return_object) = c(&quot;mean&quot;, &quot;median&quot;) return(return_object) } species_avgs = tapply(iris$Sepal.Width, iris$Species, my_avgs) species_avgs ## $setosa ## mean median ## 3.428 3.400 ## ## $versicolor ## mean median ## 2.77 2.80 ## ## $virginica ## mean median ## 2.974 3.000 Make a plot of the sepal width and sepal length. Make the points differ depending on the species type. # Starting plot, make it blank plot(iris$Sepal.Length, iris$Sepal.Width, col = &quot;white&quot;) # Custom function to add the points add_points = function(the_data, ...){ if(the_data[5]==&quot;setosa&quot;){ points(x = the_data[1], y = the_data[2], col = &quot;red&quot;, pch = 0) } else if(the_data[5]==&quot;virginica&quot;){ points(x = the_data[1], y = the_data[2], col = &quot;blue&quot;, pch = 2) } else{ points(x = the_data[1], y = the_data[2], col = &quot;green&quot;, pch = 10) } } # Use apply to add points apply(iris, 1, add_points) ## NULL Make a plot of the sepal width and sepal length. Make the points differ depending on the species type. Add the (arithmetic) mean of these two variables for each group. # ------ PLOT FROM BEFORE # Starting plot, make it blank plot(iris$Sepal.Length, iris$Sepal.Width, col = &quot;white&quot;) apply(iris, 1, add_points) ## NULL # ------ # Split the data into a list by factor split_iris = split(iris, f = iris$Species) # Iterate through the list and add (black) points to the plot lapply(split_iris, function(species_data){ points(mean(species_data$Sepal.Length), mean(species_data$Sepal.Width), pch = 16) }) ## $setosa ## NULL ## ## $versicolor ## NULL ## ## $virginica ## NULL Lets try using another example. Suppose we wish to use the following formula (below) with a = Sepal.Length, b = Sepal.Width, and c = Petal.Length. \\[ \\frac{-b + \\sqrt{b^2-4ac} }{2a}\\] Now there is more efficient ways to do this in R, but lets practice how we would do it with mapply as an example. my_formula = function(a, b, c){ num = (-b + sqrt(b^2 + 4*a*c)) den = 2*a answer = num/den return(answer) } formula_results = mapply(my_formula, a = iris$Sepal.Length, b = iris$Sepal.Width, c = iris$Petal.Length) head(formula_results) ## [1] 0.2831638 0.3098526 0.2860609 0.3260870 0.2800000 0.3061340 Additional Resources http://adv-r.had.co.nz/Functionals.html "]]
