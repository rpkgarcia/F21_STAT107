[["index.html", "STAT 107 Outline of Class Notes Welcome", " STAT 107 Outline of Class Notes Rebecca Kurtz-Garcia 2021-11-17 Welcome Welcome to STAT 107! This document will contain and outline of the course notes throughout the quarter. Please see the course website for an approximate schedule. In each of the chapters there will be a list of links, resources, and videos for learning more about an individual topic. This document will be updated constantly, be sure to check here for periodic updates. In addition, this document does not serve as a substitute for in class instruction, but more as a guide for the general content we discuss. Students are still expected to attend every lecture. "],["introduction-to-r.html", "Chapter 1 Introduction to R 1.1 Download and Install R and Rstudio 1.2 The RStudio Interface 1.3 Comments 1.4 Operators 1.5 Additional Resources", " Chapter 1 Introduction to R In this chapter we introduce R and RStudio, which you’ll be using throughout this course to learn how to analyze real data and come to informed conclusions. To straighten out which is which: R is the name of the programming language itself, and RStudio is a convenient interface for using R. As the course progresses, you are encouraged to explore beyond what we discuss; a willingness to experiment will make you a much better scientist and researcher. Before we get to that stage, however, you need to build some competence in R. We begin with some of the fundamental building blocks of R and Rstudio: the interface, data types, variables, importing data, and plotting data. R is widely used by the scientific community as a no-cost alternative to expensive commercial software packages like SPSS and MATLAB. It is both a statistical software analysis system and a programming environment for developing scientific applications. Scientists routinely make available for free R programs they have developed that might be of use to others. Hundreds of packages can be downloaded for all types of scientific computing applications. This chapter was written by the help of Dr. Robert Desharnais (2020). 1.1 Download and Install R and Rstudio To get started, you need to download both the R and Rstudio software. Both are available for free and there are versions for Linux, Mac OS X, and Windows. It is suggested that you download R first and then Rstudio. R can be used without RStudio, but RStudio provides a convenient user interface and programming environment for R. The details for downloading and installing these software packages varies depending on your computer and operating system. You may need permission to install the software on your computer. The links below provide access to a mirror archive at UCLA for downloading R and the developer’s site for downloading RStudio. To download R, go to the url https://ftp.osuosl.org/pub/cran. Choose the binary distribution appropriate for your computer. Windows users will want to click on the link to “Download R for Windows” and choose “install R for the first time,” then “Download R 3.5.2 for Windows.” Mac OS users will want to click “Download R for (Mac) OS X.” Download the install package for version R-3.5.2 If you are using Mac OS X 10.9-10.10, install version R-3.3.3. If you are using OS X 10.6-10.8, install version R-3.2.1. Linux users will want to click on the link to “Download R for Linux.” You will need to choose the version of Linux that corresponds to your installation. Versions are available for Debian, RedHat, SUSE, and Ubuntu. For RStudio, use the url https://www.rstudio.com/products/rstudio/download/. Choose the binary distribution appropriate for your computer. Installers are provided for a variety of platforms. For additional help please see this video: Getting Started 1 | How to Download and Install RStudio 1.2 The RStudio Interface We will begin by looking at the RStudio software interface. Launch RStudio. You will see a window that looks like the figure above. There are four panels of the window: The pane in the bottom left is the R Command Console is where you type R commands for immediate execution. The pane in the upper left portion of the window is an area for editing R source code for scripts and functions and for viewing R data frame objects. New tabs will be added as new R code files and data objects are opened. The pane in the upper right portion of the window is an area for browsing the variables in the R workspace environment and the R command line history. The pane in the lower right portion of the window has several tabs. The Files tab is an area for browsing the files in the current working directory. The Plot tab is for viewing graphics produced using R commands. The Packages tab lists the R packages available. Other packages can be loaded. The Help tab provides access to the R documentation. The Viewer tab is for viewing local web content in the temporary session directory (not files on the web). Bottom Left Pane Let’s begin with the Console. This is where you type R commands for immediate execution. Click in the Command Console, “&gt;” symbol is the system prompt. You should see a blinking cursor that tells you the console is the current focus of keyboard input. Type: 1+2 ## [1] 3 The result tells you that the line begins with the first (and only) element of the result which is the number 3. You can also execute R’s built-in functions (or functions you add). Type the following command. exp(pi) ## [1] 23.14069 In R, “pi” is a special constant to represent the number and “exp” is the exponential function. The result tells you that the first (and only) element of the result is the number \\(e^{\\pi}=\\) 23.14069. Bottom Right Pane Now let’s look at the Files tab of the notebook at the lower right of the window. Every R session has a working directory where R looks for and saves files. It is a good practice to create a different directory for every project and make that directory the working directory. For example, let’s make a new directory called MyDirectory. (You can chose another name if you wish). Click on the Files tab of the notebook. You should see a listing of files in your default working directory. Click on the small button with an ellipsis image on the right side of the file path above the directory listing. Navigate to the folder where you want to create the new directory and click the OK button. Click on the New Folder button just below the Files tab (see right). Type MyDirectory in the panel that opens click on the folder in the Notebook. Click the More button to the right of the New Folder button and select the menu option Set as Working Directory. This new folder is now the working directory for the current R session. This menu option is a short cut for a command that was automatically entered into the R console. Top Right Pane Next we will look at the R environment, also called the R workspace. This is where you can see the names and other information on the variables that were created during your R session and are available for use in other commands. In the R console type: a = 29.325 b = log(a) c = a/b Look at the Environment pane. The variables a, b, and c are now part of your R work space. You can reuse those variables as part of other commands. In the R console type: v= c(a, b, c) v ## [1] 29.325000 3.378440 8.680041 The variable v is a vector created using the concatenate function c(). (The concatenate should not be confused with the variable c that was created earlier. Functions are always followed by parentheses that contain the function arguments.) This function combines its arguments into a vector or list. Look at the Environment panel. The text num [1:3] tells us that the variable v is a vector with elements v[1], v[2], and v[3]. Top Left Pane Now let’s look at the R viewer notebook. This panel can be used to data which are data frame objects or matrix objects in R. We will begin by taking advantage of a data frame object that was built into R for demonstration purposes. We will copy it into a data frame object. In the R console, type: df = mtcars Let’s view the data. On the right side of the entry for the df object is a button we can use to view the entries of the data frame. Click on the View Button. If your look in the notebook area in the upper left portion of the window, you can see a spreadsheet-like view of the data. This is for viewing only; you cannot edit the data. Use the scroll bars to view the data entries. You can also list the data in the console by typing the name of the data fame object: df ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 The columns are labeled with the names of the variables and the rows are labeled with the names of each car. Each row represents the data values for one car; that is, each row is one observation. 1.3 Comments Often times we will want to add a comment to our script document so we can remember special aspects later, and make the code easier to read and modify in the future. To add a comment start the comment with a # symbol. This will make the remaining characters in a line a comment and R will not try to compile these lines. Go to the script document and type the following. Highlight what you have typed and press “Run”. # This is a comment 2+ 2 ## [1] 4 2 + 3 # Comments can also start in the middle of a line. ## [1] 5 1.4 Operators An operator is a symbol that tells the compiler to preform a specific task. There are several types of operators, some preform mathematical tasks, logical checks, and create new objects. We will review a few of the basic operators here. We will continue to discuss and introduce operators throughout this document. Arithmetic Operators R was designed for statistical applications and as a necessity it needs to preform mathematical operations efficiently and effectively. The first operators we discuss are a few of the basic arithmetic operations. These are operations similar to that of a calculator. # Addition 2+ 3 ## [1] 5 # Subtraction 2 - 3 ## [1] -1 # Multiplication 2*3 ## [1] 6 # Division 2/3 ## [1] 0.6666667 # Exponent 2^3 ## [1] 8 Relational Operators Relational operators are used to compare two values. When using a relational operation R will return either TRUE or FALSE. # Less than 2 &lt; 3 ## [1] TRUE # Greater than 2 &gt; 3 ## [1] FALSE # Less than or equal to 2 &lt;= 3 ## [1] TRUE # Greater than or equal to 2&gt;= 3 ## [1] FALSE # Not equal to 2 != 3 ## [1] TRUE # Equal to 2 == 3 ## [1] FALSE We can use all the same operators above if our object contains more than one element. This will preform the above comparisons element by element. v ## [1] 29.325000 3.378440 8.680041 v &gt; 10 ## [1] TRUE FALSE FALSE If we have two vectors of an unequal length then the checks will be preformed element-by-element but the values in the shorter vector will be recycled, or repeated. w = c(10, 1) v &gt; w ## Warning in v &gt; w: longer object length is not a multiple of shorter object ## length ## [1] TRUE TRUE FALSE R evaluated the first and third element of v and compared it to the first element of w, and the second element of v to the second element of w. In this case, R returned a warning alerting you that it recycled elements. However, R will not always give a warning. Logical operators Logical operators are similar to relational operators. They are used to check “AND” and “OR” events. We have the &amp; symbol which returns TRUE only if BOTH conditions are true. We also have the | symbol which returns TRUE if EITHER condition is true. # Check if both operations are true. (2 &lt; 3) &amp; (5 &lt; 4) ## [1] FALSE # Check if either operation is true. (2 &lt; 3) | (5 &lt; 4) ## [1] TRUE We can also negate a TRUE or FALSE value using the ! symbol. # Negate an operation !(2&lt;3) ## [1] FALSE Like relational operators from before, if we have more than one element the logical operations will be implemented element-by-element. # AND event, compared element-by-element (v &gt; 10) &amp; (4 &lt; 5) ## [1] TRUE FALSE FALSE # OR event, compared elmeent-by-elment (v &gt; 10) | (4 &lt; 5) ## [1] TRUE TRUE TRUE We also have the symbols &amp;&amp; and || which will ensure that only the first element in an object will be compared. # AND event, only check the first element (v &gt; 10) &amp;&amp; (4 &lt; 5) ## [1] TRUE # OR event, only check the first element (v &gt; 10) || (4 &lt; 5) ## [1] TRUE Assignment Operators Assignment operators are used to assign values to a new object. There are many types of assignment operators, and they operate slightly differently. The two most common assignment operators are = and &lt;-. With these operators the value to the left of the operator is the name of the new object and the value on the right is what the object is now equal to. x = 5 x ## [1] 5 x &lt;- 5 x ## [1] 5 The majority of the time we can use these two assignment operators above interchangeably, there are some exceptions though. There are several other assignment operators which are uncommon and should only be used by advanced users, -&gt;, &lt;&lt;-, and -&gt;&gt;. 1.5 Additional Resources Chapter 1 of “CRAN Intro-to-R Manual” Videos: Getting Started 1 | How to Download and Install RStudio Getting Started 2 | Rstudio Introduction cont’d, More Tabs Explained References "],["introduction-to-r-objects.html", "Chapter 2 Introduction to R Objects 2.1 Atomic Objects 2.2 Vectors 2.3 Lists 2.4 Matrices 2.5 Factors 2.6 Data Frames 2.7 Other Object Types and the Global Environment 2.8 Additional Resources", " Chapter 2 Introduction to R Objects At its core, R is an objected-oriented computational and programming environment. Everything in R is an object belonging to a certain class. In this chapter we begin by discussing atomic objects, these are the core fundamental objects used in R. Next we discuss vectors, lists, and matrices. These objects are among the most common types that are used. Lastly we discuss factors and data frames. Factors and data frames are known as dynamic objects, and are more complex. All of these objects have special properties and a multitude of features that we can use. We discuss some of their key properties here, but will continue exploring and learning about their features, and introducing more object types throughout the course. 2.1 Atomic Objects R can represent different types of data. The types include numeric, integer, complex, logical, character, and raw. These are the basic fundamental objects we can use in R. For our class we will not need the complex type which stores complex numbers, and in practice raw is rarely used. We will concentrate on the remaining four types. Unlike other object-oriented languages we do not need to specify what type of object we are creating when we create it. Instead, R guesses the type of object you are creating. To check the object type we can use the class() function. Numeric Numeric objects are perhaps the most common. These are objects which contain a real number, that is, a number which can contain a decimal value. These objects are comparable to doubles in C. a = 17.45 a ## [1] 17.45 class(a) ## [1] &quot;numeric&quot; b = 5 b ## [1] 5 class(b) ## [1] &quot;numeric&quot; Both the variables a and b are numeric objects. When you type a number R will default to treating it as a numeric object which allows decimals. Integer We can also create numeric objects which are specifically made to store integer values. We can do this using the as.integer() function. a = as.integer(a) a ## [1] 17 class(a) ## [1] &quot;integer&quot; b = as.integer(b) b ## [1] 5 class(b) ## [1] &quot;integer&quot; Logical Logical values are either TRUE or FALSE and are created by using logical and relational operators. In other words, they are created by using statements that compare variables. There are several ways to do logical statements as we saw in Section 1.4. b = 5 n = (10&lt;11) n ## [1] TRUE class(n) ## [1] &quot;logical&quot; We can also assign a value as TRUE or FALSE manually by setting it equal to TRUE or FALSE, or by using T or F. c = T c ## [1] TRUE class(c) ## [1] &quot;logical&quot; Character Character values are text. They are often used as data values and labels. first = &quot;George&quot; first ## [1] &quot;George&quot; class(first) ## [1] &quot;character&quot; last = &quot;Washington&quot; last ## [1] &quot;Washington&quot; class(last) ## [1] &quot;character&quot; There are several functions that can operate on character strings. full = paste(first, last) full ## [1] &quot;George Washington&quot; nchar(full) ## [1] 17 tolower(full) ## [1] &quot;george washington&quot; toupper(full) ## [1] &quot;GEORGE WASHINGTON&quot; The function paste() concatenates two or more character strings with a separator, which is a space by default. The function nchar() returns the number of characters in a string. The functions tolower() and toupper() changes any upper case characters to lower case and vice-versa. 2.2 Vectors All the objects we have created this far are single element vectors. R is a vectorized language, meaning most of the procedures, functions, and operations have been optimized to work with vectors. It is typically advantageous to utilize this feature. A vector is a collection of values of the same data type. We can use the concatenate function, c(), to create vectors, and to make a vector larger. v1 = c(19, 390.3, pi, -32.1) v1 ## [1] 19.000000 390.300000 3.141593 -32.100000 class(v1) ## [1] &quot;numeric&quot; v2 = c(1.1, 6, -9.4, 32.1) v2 ## [1] 1.1 6.0 -9.4 32.1 class(v2) ## [1] &quot;numeric&quot; If we try to create a vector with a mix of classes R will convert all the objects to be the same class. In general, it is easiest to convert objects into a character but hard to convert character into something else. Be cautious when mixing data types and vectors because you will not be notified if objects are converted, and they may not be converted to the class you intended. v3 = c(v1, first) class(v3) ## [1] &quot;character&quot; v4 = c(first, last) class(v4) ## [1] &quot;character&quot; The length() function can be used to obtain the number of elements in a vector. length(v1) ## [1] 4 Vectors can be used in arithmetic computations. If the two vectors are of the same length, the computations are performed element-by-element. v1 + v2 ## [1] 20.100000 396.300000 -6.258407 0.000000 v1 * v2 ## [1] 20.90000 2341.80000 -29.53097 -1030.41000 Single numbers (scalars) will operate on all the vector elements in an expression. 5*v1 ## [1] 95.00000 1951.50000 15.70796 -160.50000 v1/3 ## [1] 6.333333 130.100000 1.047198 -10.700000 Individual elements of a vector can be obtained using an index in square brackets. A negative index removes that element from the vector. The v2[-1] is the vector v2 with the first element removed. The concatenate function can be used to obtain two or more elements of a vector in any desired order. Here v1[c(3,2)] returns the third and second elements of the vector v1. v1[3] ## [1] 3.141593 v2[-1] ## [1] 6.0 -9.4 32.1 v3[c(3,2)] ## [1] &quot;3.14159265358979&quot; &quot;390.3&quot; 2.3 Lists Lists are thought of as a vector with a variety of classes. A list is made up of elements, and each element can be of a different class. lst = list(4, v4, v2) lst ## [[1]] ## [1] 4 ## ## [[2]] ## [1] &quot;George&quot; &quot;Washington&quot; ## ## [[3]] ## [1] 1.1 6.0 -9.4 32.1 class(lst) ## [1] &quot;list&quot; We can observe the class of each element in the list by using the str() function. str(lst) ## List of 3 ## $ : num 4 ## $ : chr [1:2] &quot;George&quot; &quot;Washington&quot; ## $ : num [1:4] 1.1 6 -9.4 32.1 The above output tells us we have a list of three objects. The first object is a numeric vector with one element, the second object is a character vector with two elements, and third object is a numeric vector with four elements. We can subset elements in a list using double brackets we [[]]. Inside these square brakets we state the element we would like to obtain. lst[[1]] ## [1] 4 class(lst[[1]]) ## [1] &quot;numeric&quot; To determine how long our list is we can use the length() function. length(lst) ## [1] 3 2.4 Matrices A matrix is a two dimensional array of data of the same type. The matrix function, matrix(), can be used to create a new matrix. m = matrix(c(1, 9, 2, 0, 5, 7, 3, 8, 4), nrow=3, ncol=3) m ## [,1] [,2] [,3] ## [1,] 1 0 3 ## [2,] 9 5 8 ## [3,] 2 7 4 R labels the rows and columns for us in the output. The matrix is filled column-by-column using the elements of the vector created by the concatenate function. As with vectors, matrices can be used in arithmetic operations with scalars and other matrices of the same size. m2 = m/2 m2 ## [,1] [,2] [,3] ## [1,] 0.5 0.0 1.5 ## [2,] 4.5 2.5 4.0 ## [3,] 1.0 3.5 2.0 m *m2 ## [,1] [,2] [,3] ## [1,] 0.5 0.0 4.5 ## [2,] 40.5 12.5 32.0 ## [3,] 2.0 24.5 8.0 Indices can be used to obtain the elements of a matrix, but now we must consider both the row and column. m[2,2] ## [1] 5 m[c(1,3), c(1,3)] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 m[2,] ## [1] 9 5 8 m[,3] ## [1] 3 8 4 Some functions are particularly useful when using matrices. For instance, t(), dim(), and c(). The transpose function, t(), switches the column and rows of a matrix. The dimension function, dim(), returns the dimensions (number of rows, columns) of a matrix. The concatenate function, c(), turns a matrix into a vector by concatenating the columns of the matrix. # Dimensions (row, column) dim(m) ## [1] 3 3 # Transpose t(m) ## [,1] [,2] [,3] ## [1,] 1 9 2 ## [2,] 0 5 7 ## [3,] 3 8 4 # Convert to vector c(m) ## [1] 1 9 2 0 5 7 3 8 4 2.5 Factors Factors are useful for categorical data. Factors differ from character objects in that a character object is a string of characters or symbols placed in a specific order. For example, the object first = \"George\" is a character object with six elements. In contrast, the collection of values “George” would instead represent a distinct value, or level, for a factor object. We can create a factor object using the factor() function. colors = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;red&quot;, &quot;blue&quot;) colors = factor(colors) colors ## [1] red blue red red blue ## Levels: blue red class(colors) ## [1] &quot;factor&quot; Here the unique elements in the factor are called “levels”. There are only two levels red and blue, and there are five elements in our factor object. We can index factors in the same way we index a list. # Return first element in the factor object colors[1] ## [1] red ## Levels: blue red 2.6 Data Frames Like a matrix, a data frame is a rectangular array of values where each column is a vector, However, unlike a matrix, the columns can be different data types. We can create a set of vectors of the same length and use the data.frame() function to make a data frame object. age = c(1, 8, 10, 30, 31) gender = c(&quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;,&quot;Female&quot;,&quot;Male&quot;) married = c(FALSE, FALSE, FALSE, TRUE, TRUE) simpsons = data.frame(age, gender, married) simpsons ## age gender married ## 1 1 Female FALSE ## 2 8 Female FALSE ## 3 10 Male FALSE ## 4 30 Female TRUE ## 5 31 Male TRUE class(simpsons) ## [1] &quot;data.frame&quot; Data frames can be indexed using the same techniques as was done with matrices. 2.7 Other Object Types and the Global Environment There are more objects then what we have discussed above. For example, many of the advanced functions create specific objects generated by that specific function. There are hundreds, and possibly thousands, of such objects. These objects generally are special cases of lists, factors, and other various types of objects that we have defined in this section. The objects we have described here are the building blocks of most values we will be working with. Functions like class() and length() are also considered as objects, but are of a different type. We discuss functions in more detail in section 5. There are also built-in, or special objects in R. For example, the object pi is an object already defined. These built-in values and functions can be written over, but that is not advised. pi ## [1] 3.141593 Every time we create an object we see that the Global Environment tab in the top right pane updates. The object we have created is now listed in the Global Environment. This is a collection of all user created objects in R, that R knows about, and that R can easily call. Built-in objects, such as pi, will not be listed here. 2.8 Additional Resources Chapters 2, 3, 4.1, 4.3, 5.1-5.3, 6 of CRAN Intro-to-R Manual Videos: Variables 1 | Types and Assignments Variables 2 | Nameing Conventions and Best Practices Vectors 1 | Introduction Vectors 2 | Subsetting and Modifying Vectors 3 | Vectorized Functions - Logical Comparisons Matrices 1 | Introduction Matrices 2 | Accessing Rows and Columns "],["more-on-r-objects.html", "Chapter 3 More on R Objects 3.1 Factors 3.2 Lists", " Chapter 3 More on R Objects Factors and lists have especially unique properties that are often utilized. In this chapter we take special care to discuss these properties. 3.1 Factors In real-world problems, you often encounter data that can be classified in categories. For example, suppose a survey was conducted of a group of seven individuals, who were asked to identify their hair color and if they own a pet. name = c(&quot;Amy&quot;, &quot;Bob&quot;, &quot;Eve&quot;, &quot;Kim&quot;, &quot;Max&quot;, &quot;Ray&quot;, &quot;Sam&quot;) hair = c(&quot;Blonde&quot;, &quot;Black&quot;, &quot;Black&quot;, &quot;Red&quot;, &quot;Blonde&quot;, &quot;Brown&quot;, &quot;Black&quot;) own_pets = c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE) catagorical = data.frame(name, hair, own_pets) colnames(catagorical) = c(&quot;Name&quot;, &quot;Hair Color&quot;, &quot;Own Pets&quot;) catagorical ## Name Hair Color Own Pets ## 1 Amy Blonde TRUE ## 2 Bob Black FALSE ## 3 Eve Black TRUE ## 4 Kim Red TRUE ## 5 Max Blonde FALSE ## 6 Ray Brown FALSE ## 7 Sam Black FALSE Here, the hair color and pet ownership are examples of categorical data. For the hair color variable we will typically want to store it as a factor, as opposed to a character vector. The different values that the factor can take are called levels. In R, you can create a factor with the factor() function. f = factor(hair) f ## [1] Blonde Black Black Red Blonde Brown Black ## Levels: Black Blonde Brown Red A factor looks like a vector, but it has special properties. Levels are one of them. Notice that when you print the factor, R displays the distinct levels below the factor. R keeps track of all the possible values in a vector, and each value is called a level of the associated factor.The levels() function shows all the levels from a factor. levels(f) ## [1] &quot;Black&quot; &quot;Blonde&quot; &quot;Brown&quot; &quot;Red&quot; If your vector contains only a subset of all the possible levels, then R will have an incomplete picture of the possible levels. Consider the following example of a vector consisting of directions: directions = c(&quot;North&quot;, &quot;West&quot;, &quot;North&quot;, &quot;East&quot;, &quot;North&quot;, &quot;West&quot;, &quot;East&quot;) f = factor(directions) f ## [1] North West North East North West East ## Levels: East North West Notice that the levels of your new factor do not contain the value “South”. So, R thinks that North, West, and East are the only possible levels. However, in practice, it makes sense to have all the possible directions as levels of your factor. To add all the possible levels explicitly, you specify the levels argument of the function factor(). directions = c(&quot;North&quot;, &quot;West&quot;, &quot;North&quot;, &quot;East&quot;, &quot;North&quot;, &quot;West&quot;, &quot;East&quot;) f = factor(directions, levels = c(&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;)) f ## [1] North West North East North West East ## Levels: North East South West R lets you assign abbreviated names for the levels. You can do this by specifying the labels argument of factor(). directions = c(&quot;North&quot;, &quot;West&quot;, &quot;South&quot;, &quot;East&quot;, &quot;West&quot;, &quot;North&quot;, &quot;South&quot;) f = factor(directions, levels = c(&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;), labels = c(&quot;N&quot;, &quot;E&quot;, &quot;S&quot;, &quot;W&quot;)) f ## [1] N W S E W N S ## Levels: N E S W Sometimes data has some kind of natural order between elements. For example, sports analysts use a three-point scale to determine how well a sports team is competing: loss &lt; tie &lt; win. In market research, it’s very common to use a five point scale to measure perceptions: strongly disagree &lt; disagree &lt; neutral &lt; agree &lt; strongly agree. Such kind of data that is possible to place in order or scale is known as ordinal data. We can store ordinal data as an ordered factor. To create an ordered factor, use the factor() function with the argument ordered=TRUE. record = c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;win&quot;) f = factor(record, ordered = TRUE) f ## [1] win tie loss tie loss win win ## Levels: loss &lt; tie &lt; win You can also reverse the order of levels using the rev() function. record = c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;win&quot;) f = factor(record, ordered = TRUE, levels = rev(levels(f))) f ## [1] win tie loss tie loss win win ## Levels: win &lt; tie &lt; loss If you have no observations in one of the levels, you can drop it using the droplevels() function. record = c(&quot;win&quot;, &quot;loss&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;loss&quot;, &quot;win&quot;) f = factor(record, levels = c(&quot;loss&quot;, &quot;tie&quot;, &quot;win&quot;)) f ## [1] win loss loss win loss win ## Levels: loss tie win droplevels(f) ## [1] win loss loss win loss win ## Levels: loss win The summary() function will give you a quick overview of the contents of a factor. f = factor(hair) f ## [1] Blonde Black Black Red Blonde Brown Black ## Levels: Black Blonde Brown Red summary(f) ## Black Blonde Brown Red ## 3 2 1 1 The function table() tabulates observations. table(f) ## f ## Black Blonde Brown Red ## 3 2 1 1 3.2 Lists A list is an array of objects. Unlike vectors and matrices, the elements in a list can belong to different classes. Lists are useful for packaging together a set of related objects. We can create a list of objects in our environment by using the list() function. lst = list(1, 2, 3) # A list of characters lst = list(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) # A list of mixed datatypes lst = list(1, &quot;abc&quot;, 1.23, TRUE) The best way to understand the contents of a list is to use the structure function str(). It provides a compact display of the internal structure of a list. lst = list(1, &quot;abc&quot;, 1.23, TRUE) str(lst) ## List of 4 ## $ : num 1 ## $ : chr &quot;abc&quot; ## $ : num 1.23 ## $ : logi TRUE A list can contain sublists, which in turn can contain sublists themselves, and so on. This is known as nested list or recursive vectors. lst = list(1, 3, &quot;abc&quot;, list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), TRUE) str(lst) ## List of 5 ## $ : num 1 ## $ : num 3 ## $ : chr &quot;abc&quot; ## $ :List of 3 ## ..$ : chr &quot;a&quot; ## ..$ : chr &quot;b&quot; ## ..$ : chr &quot;c&quot; ## $ : logi TRUE There are two ways to extract elements from a list: Using [[]] gives you the element itself. Using [] gives you a list with the selected elements You can use [] to extract either a single element or multiple elements from a list. However, the result will always be a list. # extract 2nd element lst[2] ## [[1]] ## [1] 3 # extract 5th element lst[5] ## [[1]] ## [1] TRUE # select 1st, 3rd and 5th element lst[c(1,3,5)] ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;abc&quot; ## ## [[3]] ## [1] TRUE # exclude 1st, 3rd and 5th element lst[c(-1,-3,-5)] ## [[1]] ## [1] 3 ## ## [[2]] ## [[2]][[1]] ## [1] &quot;a&quot; ## ## [[2]][[2]] ## [1] &quot;b&quot; ## ## [[2]][[3]] ## [1] &quot;c&quot; You can use [[]] to extract only a single element from a list. Unlike [], [[]] gives you the element itself. # extract 2nd element lst[[2]] ## [1] 3 # extract 5th element lst[[5]] ## [1] TRUE You can’t use logical vectors or negative numbers as indices when using [[]]. The difference between [] and [[]] is really important for lists, because [[]] returns the element itself while [] returns a list with the selected elements. The difference becomes clear when we inspect the structure of the output – one is a character and the other one is a list. lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) class(lst[[1]]) ## [1] &quot;character&quot; class(lst[1]) ## [1] &quot;list&quot; Each list element can have a name. You can access individual element by specifying its name in double square brackets [[]] or use $ operator. months = list(JAN=1, FEB=2, MAR=3, APR=4) # extract element by its name months[[&quot;MAR&quot;]] ## [1] 3 # same as above but using the $ operator months$MAR ## [1] 3 # extract multiple elements months[c(&quot;JAN&quot;,&quot;APR&quot;)] ## $JAN ## [1] 1 ## ## $APR ## [1] 4 You can access individual items in a nested list by using the combination of [[]] or $ operator and the [] operator. lst = list(item1 = 3.14, item2 = list(item2a = 5:10, item2b = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;))) # preserve the output as a list lst[[2]][1] ## $item2a ## [1] 5 6 7 8 9 10 # same as above but simplify the output lst[[2]][[1]] ## [1] 5 6 7 8 9 10 # same as above with names lst[[&quot;item2&quot;]][[&quot;item2a&quot;]] ## [1] 5 6 7 8 9 10 # same as above with $ operator lst$item2$item2a ## [1] 5 6 7 8 9 10 # extract individual element lst[[2]][[2]][3] ## [1] &quot;c&quot; Modifying a list element is pretty straightforward. You use either the [[]] or the $ to access that element, and simply assign a new value. # Modify 3rd list element lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) lst[[3]] = 1 str(lst) ## List of 6 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : num 1 ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; ## $ : chr &quot;f&quot; You can modify components using [] as well, but you have to assign a list of components. # Modify 3rd list element using [] lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) lst[3] = list(1) str(lst) ## List of 6 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : num 1 ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; ## $ : chr &quot;f&quot; Using [] allows you to modify more than one component at once. # Modify first three list elements lst = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;) lst[1:3] = list(1,2,3) str(lst) ## List of 6 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : chr &quot;d&quot; ## $ : chr &quot;e&quot; ## $ : chr &quot;f&quot; You can use same method for modifying elements and adding new one. If the element is already present in the list, it is updated else, a new element is added to the list. # Add elements to a list lst = list(1, 2, 3) lst[[4]] = 4 str(lst) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 By using append() method you can append one or more elements to the list. # Add more than one element to a list lst = list(1, 2, 3) lst = append(lst,c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) str(lst) ## List of 6 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : chr &quot;c&quot; By using a logical vector, you can remove list elements based on the condition. # Remove all negative list elements lst = list(-4,-3,-2,-1,0,1,2,3,4) lst[lst &lt;= 0] = NULL str(lst) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 The c() does a lot more than just creating vectors. It can be used to combine lists into a new list as well. lst1 = list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) lst2 = list(1,2,3) lst = c(lst1, lst2) str(lst) ## List of 6 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : chr &quot;c&quot; ## $ : num 1 ## $ : num 2 ## $ : num 3 Basic statistical functions work on vectors but not on lists. For example, you cannot directly compute the mean of list of numbers. In that case, you have to flatten the list into a vector using unlist() first and then compute the mean of the result. lst = list(5, 10, 15, 20, 25) mean(unlist(lst)) ## [1] 15 To find the length of a list, use length() function. length(lst) ## [1] 5 "],["working-with-data-sets.html", "Chapter 4 Working with Data Sets 4.1 Getting Data Sets in Our Working Environment 4.2 Basic Data Manipulation", " Chapter 4 Working with Data Sets In this section we discuss different methods for loading data sets into our R session. There are many different files we can create and import. We will focus our attention on loading csv files because they tend to be easier to import, and they are one of the more typical file types that are used. In the second half of the this chapter we introduce basic data manipulation strategies and helpful functions when working with data sets. 4.1 Getting Data Sets in Our Working Environment Built-In Data As discussed last week, there are built in objects which are not loaded into the global environment, but can be called upon at any time. For example pi returns the value 3.1415927. Similarly, there are built in data sets that are ready to be used and loaded at a moments notice. To see a list of built in data sets type in the console: data() These data sets can be used even if they are not listed in the global environment. For example, if you would like to load the data set in the global environment, run the following command: data(&quot;cars&quot;) Importing From Your Computer Although built-in data sets are convient, most the time we need to load our own datasets. We load our own data sets by using a function specifically designed for the file type of interest. This function usually uses the file path location as an argument. This can be done in many different ways; however, we will only go over two. Option 1 Download the file InsectData.csv from ELearn. Save this file in a spot in your computer you will remember. In the Environment window (upper left window), click on the Import Dataset button. A drop down menu will appear. Select the From Text (base)… option. Find the file InsectData.csv and select it. A pop up menu will appear giving you options for loading in the file, and showing a preview of what the file will look like once loaded. Select the appropriate options and click Import. A new line of code has generated in the console which will read the data into your current environment. Copy and paste this into your R script document if you would like to save this line of code for later. You will have to reload this file into your environment each time you start a new R session and would like to use this file. Option 2 Download the file InsectData.csv from ELearn. Save this file in a spot in your computer you will remember. In the lower right hand window select the File tab. Now search for the file which you have saved InsectData.csv. Click on the file InsectData.csv in order to see a dropdown menu. Select Import Dataset… A window will appear which will give you options and a preview of your file. Select appropriate options if needed then click Import. A new line of code has generated in the console which will read the data into your current environment. Copy and paste this into your R script document if you would like to save this line of code for later. You will have to reload this file into your environment each time you start a new R session and would like to use this file. Import From Online We can also download data sets from online in a variety of different ways. Below is one option. With this method we are using the same InsectData.csv file, but it has been posted online. We feed the url of where the data set has been posted into the read.csv() function in order to open the file. the_url = &quot;https://raw.githubusercontent.com/rpkgarcia/LearnRBook/main/data_sets/InsectData.csv&quot; the_data = read.csv(the_url) 4.2 Basic Data Manipulation Lets recall a few useful things about data frames. As we learned already, data sets are contained in an object called a data frame. One can view this as a specialized table or matrix of rows and columns, where each column is a data variable, such as height or age, and each row is a single observation. All of the values within a column must be the same data type (numeric,factor, logical, etc.). Data frames can be created or called within R, imported from text or spreadsheet files, or imported from the web. group = c(&quot;G1&quot;, &quot;G2&quot;, &quot;G1&quot;, &quot;G1&quot;, &quot;G2&quot;) age = c(35, 30, 31, 28, 40) height = c(65, 70, 60, 72, 68) pets = c(TRUE, TRUE, FALSE, FALSE, TRUE) mydata = data.frame(group, age, height, pets) mydata ## group age height pets ## 1 G1 35 65 TRUE ## 2 G2 30 70 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 5 G2 40 68 TRUE We have various R functions that help provide information about the data frame. # How many rows nrow(mydata) ## [1] 5 # How many columns ncol(mydata) ## [1] 4 # Rows, Columns dim(mydata) ## [1] 5 4 # Colnames colnames(mydata) ## [1] &quot;group&quot; &quot;age&quot; &quot;height&quot; &quot;pets&quot; The summary() function is a powerful command that gives you some summary statistics about the variales in the data frame. summary(mydata) ## group age height pets ## Length:5 Min. :28.0 Min. :60 Mode :logical ## Class :character 1st Qu.:30.0 1st Qu.:65 FALSE:2 ## Mode :character Median :31.0 Median :68 TRUE :3 ## Mean :32.8 Mean :67 ## 3rd Qu.:35.0 3rd Qu.:70 ## Max. :40.0 Max. :72 The summary statistics are listed below the names of the variables. Since pets is a logical variable, R gives you the frequencies of each unique value. In this example there are three values of TRUE and two values of FALSE. Since age and weight are numeric, R computes and returns the minimum, 1st quartile (25th percentile), median, mean, 3rd quartile (75th percentile), and maximum values. If you have many data values, this is a quick way to get a feel for how the data are distributed. The table() function can also be used to cross-tabulate categorical data. Let’s create a frequency table for the different groups. table(mydata$group) ## ## G1 G2 ## 3 2 We can also create a frequency table of pet status for both groups. table(mydata$group, mydata$pets) ## ## FALSE TRUE ## G1 2 1 ## G2 0 2 Indexing As with matrices, square brackets followed by the row, column can be used to return a specific data value. For example, to get the datum in the 3rd row, 2nd column. mydata[3,2] ## [1] 31 If you leave out the number before or after the comma, the entire column or row is returned. mydata[3,] ## group age height pets ## 3 G1 31 60 FALSE mydata[,2] ## [1] 35 30 31 28 40 For data frame you can also access variables by name instead of column number. Use a dollar sign and the name of the variable (no spaces). This usually makes the R code more readable. mydata$height[4] ## [1] 72 mydata$height ## [1] 65 70 60 72 68 The colon operator can be used to generate a sequence of indices. Typing a:b will produce a range of integers \\(a\\), \\(a+1\\),…, \\(b\\). mydata[2:4,] ## group age height pets ## 2 G2 30 70 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE mydata$age[3:5] ## [1] 31 28 40 You can use logical conditions to obtain subsets of the data. A logical value of TRUE will return a data row and a logical of FALSE omits that row. index_keep = (mydata$group ==&quot;G1&quot;) group1 = mydata[index_keep, ] group1 ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE This operation can also be accomplished by using the subset() function. group1 = subset(mydata, mydata$group == &quot;G1&quot;) group1 ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE To subset by all values which are NOT equal to a condition we can use the logical operator !=. group2 = subset(mydata, mydata$group != &quot;G1&quot;) group2 ## group age height pets ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE Rearranging Rows Data can be sorted using the order() function. This function returns the ranks of the variable being sorted. Including more than one variable allows a “nested sort,” where the second variable, third variable, etc., is used when there are ties in the sorting based on the previous variables. order(mydata$height) ## [1] 3 1 5 2 4 mydata[order(mydata$height),] ## group age height pets ## 3 G1 31 60 FALSE ## 1 G1 35 65 TRUE ## 5 G2 40 68 TRUE ## 2 G2 30 70 TRUE ## 4 G1 28 72 FALSE The ranks are used as row indices for the data frame. Notice that the observations are sorted by the last column, weight. We can sort by more than one variable. Let’s first sort by group alone and then by group followed by weight and see what we get. mydata[order(mydata$group), ] ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE mydata[order(mydata$group, mydata$height), ] ## group age height pets ## 3 G1 31 60 FALSE ## 1 G1 35 65 TRUE ## 4 G1 28 72 FALSE ## 5 G2 40 68 TRUE ## 2 G2 30 70 TRUE To reorder a vector from smallest to largest we can also condiser the sort() function. sort(mydata$age) ## [1] 28 30 31 35 40 Adding Columns One can add a new variable (column) to a data frame by defining a new variable and assigning values to it. Below we add a weight variable to the data frame. wghts = c(169, 161, 149, 165, 155) wghts ## [1] 169 161 149 165 155 mydata$weight = wghts mydata ## group age height pets weight ## 1 G1 35 65 TRUE 169 ## 2 G2 30 70 TRUE 161 ## 3 G1 31 60 FALSE 149 ## 4 G1 28 72 FALSE 165 ## 5 G2 40 68 TRUE 155 We can also add a new column using the cbind() function. mydata = cbind(mydata, wghts) mydata ## group age height pets weight wghts ## 1 G1 35 65 TRUE 169 169 ## 2 G2 30 70 TRUE 161 161 ## 3 G1 31 60 FALSE 149 149 ## 4 G1 28 72 FALSE 165 165 ## 5 G2 40 68 TRUE 155 155 NA values In addition, if we have a missing value, or a blank value, we can use the object NA to indicate the lack of a value. fav_color = c(&quot;Red&quot;, NA, &quot;Purple&quot;, NA, &quot;Red&quot;) mydata = cbind(mydata, fav_color) mydata ## group age height pets weight wghts fav_color ## 1 G1 35 65 TRUE 169 169 Red ## 2 G2 30 70 TRUE 161 161 &lt;NA&gt; ## 3 G1 31 60 FALSE 149 149 Purple ## 4 G1 28 72 FALSE 165 165 &lt;NA&gt; ## 5 G2 40 68 TRUE 155 155 Red We can drop check for NA values using the is.na() function. is.na(mydata) ## group age height pets weight wghts fav_color ## [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [3,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [4,] FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [5,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE We can remove all rows with NA values using na.omit(). na.omit(mydata) ## group age height pets weight wghts fav_color ## 1 G1 35 65 TRUE 169 169 Red ## 3 G1 31 60 FALSE 149 149 Purple ## 5 G2 40 68 TRUE 155 155 Red NULL One can drop a variable (column) by setting it equal to the R value NULL. mydata$wghts = NULL mydata ## group age height pets weight fav_color ## 1 G1 35 65 TRUE 169 Red ## 2 G2 30 70 TRUE 161 &lt;NA&gt; ## 3 G1 31 60 FALSE 149 Purple ## 4 G1 28 72 FALSE 165 &lt;NA&gt; ## 5 G2 40 68 TRUE 155 Red Be careful using these methods. Once a variable or row is dropped, it’s gone. Adding Rows Rows can be added to a data frame using the rbind() (row bind) function. Because our columns have different data types, we will create a list object and then add it as a new row. newobs = list(&quot;G1&quot;, 23, 62, FALSE, 160, &quot;Blue&quot;) newdata = rbind(mydata, newobs) newdata ## group age height pets weight fav_color ## 1 G1 35 65 TRUE 169 Red ## 2 G2 30 70 TRUE 161 &lt;NA&gt; ## 3 G1 31 60 FALSE 149 Purple ## 4 G1 28 72 FALSE 165 &lt;NA&gt; ## 5 G2 40 68 TRUE 155 Red ## 6 G1 23 62 FALSE 160 Blue We can also use rbind() to append one data frame to another. We can do this with the variables group1 and group2 created above still exist in your R environment. group1 ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE group2 ## group age height pets ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE rbind(group1, group2) ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE We can also remove rows from a data frame. Using negative index values has the same effect as including all the indices except the negative ones. mydata[-c(2,4), ] ## group age height pets weight fav_color ## 1 G1 35 65 TRUE 169 Red ## 3 G1 31 60 FALSE 149 Purple ## 5 G2 40 68 TRUE 155 Red "],["functions.html", "Chapter 5 Functions 5.1 Build Your Own Function 5.2 Lexical Scoping 5.3 Built-In Functions 5.4 Help Files 5.5 The … Argument 5.6 Generic Functions 5.7 Additional Resources", " Chapter 5 Functions In R we have functions, functions are another type of object in R. We use functions in order to preform a series of tasks repeatedly, or preform these tasks in different settings. They can make our code much more efficient. We can build our own functions or we can use built in functions. Here we describe both types and their properties. Parts of this chapter where adapted by John Blischak, Daniel Chen, Harriet Dashnow, and Denis Haine (2016) and Vries and Meys (2015). 5.1 Build Your Own Function To define a function, a name is assigned and the keyword function is used to denote the start of the function and its argument list. Functions are created using the function() directive and are stored as R objects just like anything else. In particular, they are R objects of class function. Functions can be passed as arguments to other functions. Functions can be nested, so that you can define a function inside another function. Below is the general template function_name = function(arg){ # Function Body .... return(return_value) } In this template we have the following key components function_name: This is the actual name of the function. It is stored in R environment as an object with this name. function: A directive which tells R a function is being created. arg: An argument is a placeholder. When a function is invoked, you pass a value to the argument. Arguments are optional; that is, a function may contain no arguments. Also arguments can have default values. function body: The function body contains a collection of statements that defines what the function does. return_value: The output value of the function. If return(return_value) is not supplied then the return value of a function is the last expression in the function body to be evaluated. Your function can only return one object. This object can be any class of object you desire, like a vector, list or data frame, but you may only return one object. Below is an example of converting a temperature from Fahrenheit to Celsius. fahrenheit_to_celsius = function(temp_F){ temp_C = (temp_F - 32) * 5 / 9 return(temp_C) } In this example the function name is fahrenheit_to_celsius, there is only one input or argument, temp_F, and the output is the object temp_C. Now if we would like to “call” this function we can simply put into the command console the function name and desired input. # Convert 87F to Celsius fahrenheit_to_celsius(temp_F = 87) ## [1] 30.55556 What would happen if we tried to call this function without supplying an input? This would result in an error. # temp_F not defined. fahrenheit_to_celsius() Error in fahrenheit_to_celsius() : argument &quot;temp_F&quot; is missing, with no default With functions we can define function arguments to have default values. These default values are used only if the user did not supply an argument value. Observe the example below. # An example function example_func = function(a = 1, b){ c = a + b d = c + 1 # returns a+b+1 return(d) } # Call example function example_func(a= 2, b= 3) ## [1] 6 example_func(b = 3) ## [1] 5 Further notice that R has three ways to match function inputs to the formal arguments of the function definition. R attempts to match inputs to arguements in the following order. by complete name by partial name (matching on initial n characters of the argument name) by position After running a function command R first attempts to match arguments by complete name, then by partial name, and then by position. If it unable to match inputs to an argument it then uses the default argument value, if one exists. Observe: example_func(2, 3) ## [1] 6 example_func(b = 3, a = 2) ## [1] 6 example_func(a = 2, b = 3) ## [1] 6 5.2 Lexical Scoping With all these examples of functions, notice that in your global environment, only the function name was added. The function arguments, return values, and all objects defined inside the function are not a part of the global environment. This is not a mistake. We can define objects locally, or temporarily, when using functions. These objects are created and used only when the function is running, and quickly discarded once the function finishes. They never are listed in the global environment. Sometimes you may have an object defined in multiple places. When this happens, R uses a system of rules to determine which definition it will use. In other words, how and where we define an object determines the objects scope, or range of places that we can use this object. The system of rules R uses for searching for objects is called lexical scoping, as opposed to other types of scoping. With this system R looks for objects that are called in a function within the itself, then any enclosing environments, then the global environment, and lastly looking at objects in packages or built-in objects. This is the same searching method that we see in Python and Java. 5.3 Built-In Functions R has functions built-in to it just like excel. You can call these built-in function at any time. We have already seen a few of these functions. c() class() matrix() data.frame() Below are a few more examples using the built-in dataset mtcars, we will use mtcars$mpg as a vector of data to analyze. mean(): Takes in a vector, and returns the mean of the values in the vector. mean(mtcars$mpg) ## [1] 20.09062 median(): Takes in a vector, and returns the median of the values in the vector. median(mtcars$mpg) ## [1] 19.2 var(): Takes in a vector, and returns the variance of the values in the vector. var(mtcars$mpg) ## [1] 36.3241 sqrt(): If you give it a vector, it returns the square root of each element in the vector. If you give it a single number, it returns the square root of the number. sqrt(mtcars$mpg) ## [1] 4.582576 4.582576 4.774935 4.626013 4.324350 4.254409 3.781534 4.939636 ## [9] 4.774935 4.381780 4.219005 4.049691 4.159327 3.898718 3.224903 3.224903 ## [17] 3.834058 5.692100 5.513620 5.822371 4.636809 3.937004 3.898718 3.646917 ## [25] 4.381780 5.224940 5.099020 5.513620 3.974921 4.438468 3.872983 4.626013 sd(): Takes in a vector, and returns the standard deviation of the values in the vector. sd(mtcars$mpg) ## [1] 6.026948 range(): Takes in a vector, and returns the minimum AND maximum of the values in the vector. range(mtcars$mpg) ## [1] 10.4 33.9 quantile(): Takes in a vector as the first argument, and a vector of values between 0 and 1 (any number of values) for the second argument. It will return the corresponding quantiles of the values in the first vector specified by the second vector. To get the \\(10^{th}\\) and \\(90^{th}\\) percentiles: quantile(mtcars$mpg,c(0.10,0.90)) ## 10% 90% ## 14.34 30.09 summary(): You can give this a dataset OR a vector. It returns some summary information about the values in the dataset or vector. summary(cars$speed) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.0 12.0 15.0 15.4 19.0 25.0 One of the great advantages of using R is that there is a ton of resources available to learn about it. However, this can also be a disadvantage because of the vast amount of information available. The best and first resource you should look at when trying learn more about R functions is the Help files. 5.4 Help Files The Help files are in R and can be viewed from the lower right window by clicking the Help tab. Here you can search by function name to read about it. Each built in function has a help files, sometimes similar functions are grouped together in the same file. The R Help Files are typically the best resource to get help. The R Help files follow a fairly standard outline. You find most of the following sections in every R Help file: Title: A one-sentence overview of the function. Description: An introduction to the high-level objectives of the function, typically about one paragraph long. Usage: A description of the syntax of the function (in other words, how the function is called). This is where you find all the arguments that you can supply to the function, as well as any default values of these arguments. Arguments: A description of each argument. Usually this includes a specification of the class (for example, character, numeric, list, and so on). This section is an important one to understand, because arguments are frequently a cause of errors in R. Details: Extended details about how the function works, provides longer descriptions of the various ways to call the function (if applicable), and a longer discussion of the arguments. Value: A description of the class of the value returned by the function. See also: Links to other relevant functions. In most of the R editors, you can click these links to read the Help files for these functions. Examples: Worked examples of real R code that you can paste into your console and run. An alternative way to view a functions help file is by typing ? followed by the function name, or by typing help(function_name). # Find a help file for the function `rep` ?rep help(rep) If you are not sure exactly which function you want, you can use ?? followed by what you believe the function name is to look at a list of functions. ??rep 5.5 The … Argument There is a special argument function ... that can be used. Sometimes we call a function within a function that has a different set of arguments. We can use the ... argument as a general placeholder for passing along any additional arguments in a function call. # Using the ... argument # This function calls fun2 fun1 = function(x, ...){ y = fun2(...) z = x + y return(z) } # Define fun2 fun2 = function(a){ b = a^2 return(b) } # Returns 1 + 2^2 = 5 fun1(1, 2) ## [1] 5 We can also use the ... arguement in a nested fashion. fun1 = function(x, ...){ y = fun2(...) z = x+ y return(z) } fun2 = function(a, ... ){ b = fun3(...) c = a^2 + b return(c) } fun3 = function(n){ n = sqrt(n) return(n) } # Returns: 1 + 2^2 + sqrt(4) = 7 fun1(1, 2, 4) ## [1] 7 # Returns: 1 + 2^2 + sqrt(4) = 7 # Define each input explicitly fun1(x = 1, a = 2, n = 4) ## [1] 7 When using the ... argument it is customary to always place ... at the end of a function argument list, as it can be difficult for R to determine which arguments are to be passed to the next function. If possible, it is good practice to explicitly define the arguments to avoid an error. 5.6 Generic Functions In R we have something called generic functions which are functions that behave differently depending on the class type of one of the arguments. Typically generic functions depend on the class of the first argument. The functions mean(), summary(), and plot() are all generic functions. These functions act as a “middle man” or a “dispatcher”. The generic function calls the actual function you desire. For example, when we call summary() and the first argument is a lm object, then the summary function that is actually run is summary.lm() which may have its own help file. 5.7 Additional Resources Chapter 14 of “R for Programming in Data Science” Chapter 13 of “Advanced R” Videos: R Functions 1 | Anatomy of a Function R Functions 2 | Getting Help R Functions 3 | Argument Order and Default Values Writing Functions 1 | Introduction Writing Functions 2 | 4 Fundamental Steps References "],["if-statements.html", "Chapter 6 If Statements 6.1 If 6.2 If Else 6.3 Else If 6.4 Ifelse 6.5 Nested If Chains 6.6 Additional Resources", " Chapter 6 If Statements If statements are a type of control flow structure. Control structures help us control how many times code is executed, and when it will be executed. This is helpful because sometime we only want our program to run if certain conditions are met. 6.1 If In R we can also execute commands only if certain conditions are met using the if operator. This feature in R checks a logical value (&lt;value&gt;) and if it is TRUE then a sequence of commands within {} will be ran. If &lt;value&gt; is FALSE, then the commands inside of {} will not be ran. if(&lt;value&gt;){ # Commands } Below we have an example. The code will only be executed if x is a positive number. x = 3 if(x&gt;0){ type = &quot;positive&quot; } type ## [1] &quot;positive&quot; In the example above we have a relational operator which returns a logical value. This logical value was equal to TRUE so the code was executed. 6.2 If Else We can pair an if statement with an else value. After the else object we can define another sequence of commands inside of {}. The else value is paired with the immediate previous if statement. If this if statement is FALSE then the else code will run. If the if statement is TRUE then the else code will not be executed. x = -3 if(class(x) == &quot;numeric&quot;){ type = &quot;number&quot; } else { type = &quot;not a number&quot; } type ## [1] &quot;number&quot; 6.3 Else If Sometimes we will want to do a sequence of checks that are all related, and we will only want code to run if the previous if statements were FALSE and another criteria is TRUE. We can use else if to implement these rules. x = -3 if(x&gt;0){ type = &quot;positive&quot; } else if (x &lt;0) { type = &quot;negative&quot; } else if(x == 0){ type = &quot;zero&quot; } else { type = &quot;Error&quot; } type ## [1] &quot;negative&quot; The command for the if statement will only run if x&gt;0, and the rest of the code will not be implemented. The first else if commands will only execute if the first if statement was FALSE and x&lt;0. The second else if commands will only execute if the previous else if and if statements were FALSE and x==0. If the previous if statement and all previous else if statements are FALSE then the else code will be executed. Here is another example with an if else chain. Toyfun = function(X,Y,Do){ if(Do == &quot;Add&quot;){ Z = X+Y }else if(Do ==&quot;Subtract&quot;){ Z = X-Y }else if(Do ==&quot;Multiply&quot;){ Z = X*Y }else if(Do ==&quot;Penguin&quot;){ Z = c(&quot;&lt;(&#39;&#39; )&quot;) } else{ Z = c(X,Y) } return(Z) } Toyfun(2,4,&quot;Add&quot;) ## [1] 6 Toyfun(2,4,&quot;Subtract&quot;) ## [1] -2 Toyfun(2,4,&quot;Penguin&quot;) ## [1] &quot;&lt;(&#39;&#39; )&quot; Toyfun(2,4, &quot;Typo&quot;) ## [1] 2 4 6.4 Ifelse We have a shortcut function that can help us keep our code more succinct using the ifelse() function. The first argument of this function is a logical value. the second and third arguments are what to do if the value is TRUE or FALSE, respectively. x = 3 type = ifelse(x&gt;0, &quot;positive&quot;, &quot;nonpositive&quot;) type ## [1] &quot;positive&quot; We can also pass ifelse() a vector, and it will check the logical condition for each element of the vector. For example, in the mtcars data set, we can find the proportion of cars have mpg &gt; 25 and hp &gt; 60 fast_efficient = ifelse(mtcars$mpg &gt; 25 &amp; mtcars$hp&gt;60, TRUE, FALSE) sum(fast_efficient)/length(fast_efficient) ## [1] 0.15625 6.5 Nested If Chains We can make if-else chains nested within each other. x = 105 if(x&gt;0){ if(x&gt;100){ type = &quot;large positive number&quot; } else { type = &quot;positive number&quot; } } else if(x&lt;0) { type = &quot;negative number&quot; } else if(x==0){ type = &quot;zero&quot; }else { type = &quot;Error&quot; } type ## [1] &quot;large positive number&quot; 6.6 Additional Resources Chapter 13 of “R for Programming in Data Science” Videos: Control Flow 1 | if Statements Control Flow 2 | if else Statements Control Flow 3 | else if Statements Control Flow 4 | ifelse Function Control Flow 5 | switch Function "],["base-r-plotting.html", "Chapter 7 Base R Plotting 7.1 Load A Big Data Set 7.2 Histograms 7.3 Boxplot 7.4 Scatter Plot 7.5 Pie Charts 7.6 Adding Extra Lines/Points/Elements to a Graph 7.7 The par() Help File 7.8 Adding Legends 7.9 The “maps” Package 7.10 What makes a good plot?", " Chapter 7 Base R Plotting 7.1 Load A Big Data Set Let use some of the methods above, and others, to analyze a real data set. The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. As its name implies, the BRFSS is designed to identify risk factors in the adult population and report emerging health trends. For example, respondents are asked about their diet and weekly physical activity, their HIV/AIDS status, possible tobacco use, and even their level of healthcare coverage. The BRFSS Web site (http://www.cdc.gov/brfss) contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data. We will focus on a random sample of 20,000 people from the BRFSS survey conducted in the year 2000. While there are over 200 variables in this data set, we will work with a smaller subset. We begin by loading the data set of 20,000 observations into the R workspace and examine some of its attributes. source(&quot;http://www.openintro.org/stat/data/cdc.R&quot;) After a brief time, a new data frame cdc appears in the workspace. Each row representing a case (a person surveyed) and each column representing a variable. To get general information on each variable, use the summary() function. summary(cdc) ## genhlth exerany hlthplan smoke100 ## excellent:4657 Min. :0.0000 Min. :0.0000 Min. :0.0000 ## very good:6972 1st Qu.:0.0000 1st Qu.:1.0000 1st Qu.:0.0000 ## good :5675 Median :1.0000 Median :1.0000 Median :0.0000 ## fair :2019 Mean :0.7457 Mean :0.8738 Mean :0.4721 ## poor : 677 3rd Qu.:1.0000 3rd Qu.:1.0000 3rd Qu.:1.0000 ## Max. :1.0000 Max. :1.0000 Max. :1.0000 ## height weight wtdesire age gender ## Min. :48.00 Min. : 68.0 Min. : 68.0 Min. :18.00 m: 9569 ## 1st Qu.:64.00 1st Qu.:140.0 1st Qu.:130.0 1st Qu.:31.00 f:10431 ## Median :67.00 Median :165.0 Median :150.0 Median :43.00 ## Mean :67.18 Mean :169.7 Mean :155.1 Mean :45.07 ## 3rd Qu.:70.00 3rd Qu.:190.0 3rd Qu.:175.0 3rd Qu.:57.00 ## Max. :93.00 Max. :500.0 Max. :680.0 Max. :99.00 The variables genhlth and gender are character variables. The summary() command reports the frequencies of the unique values. The variables exerany, hlthplan, and smoke100 are yes/no variables coded as 1=yes or 0=no. They represent the existence or absence or regular exercise, the presence of a healthcare plan, and whether or not the person smoked 100 cigarettes in their lifetime. The means are the proportion of “yes” responses. The variables height, weight, wtdesire, and age are numeric variables. The summary() command gives information on the means, medians, quartiles and range of values. Since this is a very large data set, we wouldn’t want to list all the data. We can use the functions head() and tail() to list the first and last few rows. head(cdc) ## genhlth exerany hlthplan smoke100 height weight wtdesire age gender ## 1 good 0 1 0 70 175 175 77 m ## 2 good 0 1 1 64 125 115 33 f ## 3 good 1 1 1 60 105 105 49 f ## 4 good 1 1 0 66 132 124 42 f ## 5 very good 0 1 0 61 150 130 55 f ## 6 very good 1 1 0 64 114 114 55 f tail(cdc) ## genhlth exerany hlthplan smoke100 height weight wtdesire age gender ## 19995 good 0 1 1 69 224 224 73 m ## 19996 good 1 1 0 66 215 140 23 f ## 19997 excellent 0 1 0 73 200 185 35 m ## 19998 poor 0 1 0 65 216 150 57 f ## 19999 good 1 1 0 67 165 165 81 f ## 20000 good 1 1 1 69 170 165 83 m 7.2 Histograms Histograms are one of the fundamental ways that we can represent a data set. In a histogram we typically have the frequency or proportion on the y-axis, and the x-axis is segmented into mutually exclusive sections. The height of the bins corresponds to amount of observations that fall within a specific range. We can create a histogram using the hist() function. Most of the basic R plots have default settings. For example, the x-axis, y-axis, number of bins, titles, and labels all change depending on the vector supplied into the function. # Look at the help file ?hist hist(cdc$height) hist(cdc$weight) hist(cdc$age) The output appears in the Plots panel of RStudio. You can use the arrows to the left of the Zoom button the switch among the three plots. There are several settings in base R plots that are similar. For example, in base R plots typically we can change the title, x-axis label, and y-axis label with main, xlab, and ylab arguments. hist(cdc$weight, main=&quot;Distribution of Weight&quot;,xlab=&quot;Weight (kg)&quot;) There are also function specific arguments. For example, we can control the number of bins to create. hist(cdc$weight, main=&quot;Distribution of Weight&quot;,xlab=&quot;Weight (kg)&quot;, breaks = 20) Use col argument to change the colors used for the bars. By using the border argument, you can even change the color used for the border of the bars. hist(cdc$weight, breaks=20, main=&quot;Distribution of Weight&quot;, xlab=&quot;Weight (kg)&quot;, border = &quot;mediumpurple4&quot;, col = &quot;mediumpurple1&quot;) There are several ways we can add colors to R. Using Color Names: R programming has names for 657 colors. You can take a look at them all with the colors() function, or simply check this R color pdf. Using Hex Values as Colors: Instead of using a color name, color can also be defined with a hexadecimal value. We define a color as a 6 hexadecimal digit number of the form #RRGGBB. Where the RR is for red, GG for green and BB for blue and value ranges from 00 to FF. For example, #FF0000 would be red and #00FF00 would be green similarly, #FFFFFF would be white and #000000 would be black. Using RGB Values The function rgb() allows us to specify red, green and blue component with a number between 0 and 1. This function returns the corresponding hex code discussed above. Using a Color Palette: R programming offers 5 built in color palettes which can be used to quickly generate color vectors of desired length. They are: rainbow(), heat.colors(), terrain.colors(), topo.colors() and cm.colors(). We pass in the number of colors that we want You can also place values on top of bars; which will help you interpret the graph correctly. You can add them by setting the labels argument to TRUE. hist(cdc$height[1:1000], col=&quot;dodgerblue3&quot;, labels=TRUE, ylim = c(0, 200), breaks = 18) Often you want to compare the distributions of different variables within your data. You can overlay the histograms by setting the add argument of the second histogram to TRUE. # random numbers h1 = rnorm(1000,6) h2 = rnorm(1000,4) # Overlay two histograms hist(h1, col=rgb(1,0,0,0.25)) hist(h2, col=rgb(0,0,1,0.25), add=TRUE) For more options, look up “hist” in the Help panel of RStudio. ?hist 7.3 Boxplot Let’s produce a boxplot for the first 1000 values of the height variable. boxplot(cdc$height[1:1000]) The line in the center is the median. The bottom and top of the box are drawn at the first (\\(Q_1\\)) and third (\\(Q_3\\)) quartiles (same as the 25th and 75th percentiles). The difference between the third and first quartiles is called the interquartile range (\\(Q_3-Q_1\\)). This is the height of the box. The lines above and below the box are called the whiskers. The upper whisker is either the third quartile plus 1.5 times the interquartile range, \\(Q3 +1.5(Q_3-Q_1)\\), or the largest data value, whichever is smallest. Similarly, the lower whisker is either the first quartile minus 1.5 times the interquartile range, \\(Q1-1.5(Q_3-Q_1)\\), or the smallest data value, whichever is largest. If data values exceed the whiskers, they are considered outliers (according to the \\(IQR\\) method, see Homework 2) and are plotted as circles. Boxplots are often used to represent numeric data. One can use boxplots to compare different groups using ~ character. On the right side of ~ is the numeric variable, and the left side of ~ is a grouping variable (character, logical, factor). boxplot(cdc$height[1:1000] ~ cdc$gender[1:1000]) 7.4 Scatter Plot We can create a scatter plot using the plot() function in R. This is generic function, which means that it will behave differently depending on the inputted values. For now we will on creating a simple \\(X\\) vs \\(Y\\) plot, which is what we typically want. # Help file for the GENERIC function ?plot ## Help on topic &#39;plot&#39; was found in the following packages: ## ## Package Library ## graphics /Library/Frameworks/R.framework/Versions/4.0/Resources/library ## base /Library/Frameworks/R.framework/Resources/library ## ## ## Using the first match ... # Help file for plot when using a simple X vs Y input ?plot.default # Run the command plot(cdc$height, cdc$weight) Notice that this help file has many of the same arguments as we saw with the hist() function. For example, xlab, ylab, main, and col. A lot of Base R plotting functions are related and use the same techniques and arguments. # Plot using HEX color system plot(cdc$height, cdc$weight, xlab = &quot;Height&quot;, ylab = &quot;Weight&quot;, col = &quot;#33F3FF&quot;) Other interesting features we may want to consider is having different colors points on our plot. We can supple the col argument for a vector the colors we want plotted. If the vector of is the same length as the number of rows in our data set, then the index of the vector of colors corresponds to the index of the point being plotted. If the vector of colors is not the size, then colors are generated using recycling. For example, below only two colors were supplied. This means every other point in the data set had a different color. # Plot using HEX color system plot(cdc$height, cdc$weight, xlab = &quot;Height&quot;, ylab = &quot;Weight&quot;, col = c(&quot;#33F3FF&quot;, &quot;#A833FF&quot;)) There are lots of other features we can change. Consider changing cex, type, bg, pch, ylim, xlim. 7.5 Pie Charts We will now look at some of the qualitative data that are not numbers, but categories or groups. The table() function can be used to tabulate categorical data. The genhlth variable has five categories, we can use table() to find the frequencies. table(cdc$genhlth) ## ## excellent very good good fair poor ## 4657 6972 5675 2019 677 Since the sample size is 20,000, we can divide by n to get proportions. table(cdc$genhlth)/20000 ## ## excellent very good good fair poor ## 0.23285 0.34860 0.28375 0.10095 0.03385 Pie charts are also used for categorical data. Options are also available for the pie() function. pie(table(cdc$genhlth)/20000) Options are also available for the pie() function. colors = c(&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;red&quot;) pie(table(cdc$genhlth)/20000, col = colors, main = &quot;General Health&quot;) 7.6 Adding Extra Lines/Points/Elements to a Graph Often you want to draw attention to specific values or observations in your graphic to provide unique insight. You can do this by adding markers to your graphic. For example, adding mean line will give you an idea about how much of the distribution is above and below the average. You can add such marker by using the abline() function. # Add a line on a histogram hist(cdc$weight, breaks=20, main=&quot;Distribution of Weight&quot;, xlab=&quot;Weight (kg)&quot;, border = &quot;mediumpurple4&quot;, col = &quot;mediumpurple1&quot;) abline(v=mean(cdc$weight), col=&quot;mediumblue&quot;, lty=2, lwd=2) # Add a line on scatter plot plot(cdc$height, cdc$weight, xlab = &quot;Height&quot;, ylab = &quot;Weight&quot;, col = &quot;darkblue&quot;) # Make a solid line abline(h = median(cdc$weight), col = &quot;red&quot;, lwd = 2) # Make a dashed line abline(h = median(cdc$wtdesire), col = &quot;red&quot;, lty = 2) Sometimes, we would rather add a line connecting two points, rather than a continuous vertical, horizontal or linear line. To do this we can use the lines() function. # Add a line on scatter plot plot(cdc$height, cdc$weight, xlab = &quot;Height&quot;, ylab = &quot;Weight&quot;, col = &quot;darkblue&quot;) # Add a line connecting two points. lines(x = c(55, 84), y = c(400, 200), col = &quot;red&quot;, lwd = 2) # Add a line connecting a series of points lines(x = c(50, 60, 70, 80, 90), y = c(100, 350, 225, 300, 425), col = &quot;green&quot;, lwd = 2) Similarly we can also add points to any base R graph using the points() function. # Add a line on scatter plot plot(cdc$height, cdc$weight, xlab = &quot;Height&quot;, ylab = &quot;Weight&quot;, col = &quot;darkblue&quot;) # Make a solid line points(mean(cdc$height), mean(cdc$weight), col = &quot;red&quot;, pch = 16) # Sample random points to plot set.seed(62) random_index = sample(1:nrow(cdc), 20) points(cdc$height[random_index], cdc$weight[random_index], col = &quot;yellow&quot;, pch = 8) In the points() help file we can see a separate section called pch values which contains the different types of points that Base R can create. Notice that the abline() function had arguments lty, and lwd. In addition, the points() function had the arguments cex and bg. The description for these arguments is in the par help file which contains a master set of graphical parameter arguments. In this file we can also see that main, xlab, and ylab are also listed. 7.7 The par() Help File The par file contains graphical arguments that are common in base R graphics functions. We can look inside this help file for even more arguments that may not be listed in the Base R plotting functions like hist(), plot(), points(), and abline(). It is also a function that can adjust global plotting window parameters. For example, suppose we wish to have multiple plots on plotting window. We can control this with mfrow. When adjusting global plotting parameters it is best to always revert back to the default settings when you are done. # Change plot window to have 3 columns and 1 row of plots par(mfrow = c(1, 3)) # Three plots in one window hist(cdc$height) hist(cdc$weight) hist(cdc$age) # Revert back to default par(mfrow = c(1,1)) 7.8 Adding Legends We can also consider adding a legend to our new graph using the legend() function. This function lets us put our own unique labels on different plotting aspects we created. Note that the function arguments like col, lty, and pch are used to dictate what should be on the legend. We control were the legend goes by using the first argument. This first argument x can be the the location on the x-axis, or it can be a keyword such as: “bottomright”, “bottom”, “bottomleft”, “left”, “topleft”, “top”, “topright”, “right” and “center”. # Add a line on a histogram hist(cdc$weight, breaks=20, main=&quot;Distribution of Weight&quot;, xlab=&quot;Weight (kg)&quot;, border = &quot;mediumpurple4&quot;, col = &quot;mediumpurple1&quot;) abline(v=mean(cdc$weight), col=&quot;mediumblue&quot;, lty=2, lwd=2) legend(&quot;topright&quot;, legend = c(&quot;Mean Weight&quot;), lty = 2, col = &quot;mediumblue&quot;, lwd = 2) # Add a line on scatter plot plot(cdc$height, cdc$weight, xlab = &quot;Height&quot;, ylab = &quot;Weight&quot;, col = &quot;darkblue&quot;) # Make a solid line abline(h = median(cdc$weight), col = &quot;red&quot;, lwd = 2) # Add a single point points(mean(cdc$height), mean(cdc$weight), col = &quot;red&quot;, pch = 16) # Sample random points to plot set.seed(62) random_index = sample(1:nrow(cdc), 20) points(cdc$height[random_index], cdc$weight[random_index], col = &quot;orange&quot;, pch = 8) # Make a legend legend(&quot;topleft&quot;, legend = c(&quot;All Data Values&quot;, &quot;Mean&quot;, &quot;Sample&quot;, &quot;Median Weight&quot;), pch = c(1, 16, 8, NA), col = c(&quot;darkblue&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;red&quot;), lty = c(NA, NA, NA, 1)) 7.9 The “maps” Package Base R plotting is very powerful and has many features. However, sometimes you want to create something specialized or create a more unique type of plot. There are a lot of plotting tools that can be added to base R plots by using packages. Packages are covered in more detail in Section 8. We specifically consider the maps package which lets us create different types of maps in R. For this package. library(maps) ## Warning: package &#39;maps&#39; was built under R version 4.0.2 map() This package can let us graph different types of plots : “world”, “usa”, “state”, and “county”. par(mfrow = c(2, 2)) # world map map(&quot;world&quot;) # USA map map(&quot;usa&quot;) map(&quot;state&quot;) map(&quot;county&quot;) par(mfrow = c(1,1)) Within these maps we can specify specific regions that we may want plotted. In general, it supports the names of countries, and states in the US. par(mfrow = c(1,2)) map(&quot;world&quot;, regions = &quot;Switzerland&quot;) map(&quot;state&quot;, regions = &quot;oklahoma&quot;) par(mfrow = c(1,1)) These functions have some of the same features of our normal Base R functions. For example, we can still add points and lines to these graphs, but now we have to do it in the correct coordinate system. For example, we can plot the locations of world cities that are capitals using the data set world.cities which is part of the maps package using the base R plot function points(). map(&quot;world&quot;) captial_cities = world.cities[world.cities$capital==1, ] points(captial_cities$long, captial_cities$lat, col = &quot;red&quot;) The maps package does not work with labels well. However, if we wish to add labels we can instead use the function map.text(). par(mfrow = c(1,2)) # Default Label map.text(&quot;world&quot;, regions = &quot;Switzerland&quot;) # Custom Label map.text(&quot;state&quot;, regions = &quot;oklahoma&quot;, labels = &quot;Custom Label Here&quot;) par(mfrow = c(1,1)) 7.10 What makes a good plot? It takes practice both to create and identify good plots. In general plots should have the following properties. Informative Title Appropriate Labelled Axis Nothing Cutoff Units of measurement listed Legends (when applicable) Communicate a clear message This is not an exhaustive list, but contains a general quick check list of items to consider when creating plots. "],["packages.html", "Chapter 8 Packages 8.1 Namespace Collisions", " Chapter 8 Packages R packages are a collection of R functions, complied code and sample data. They are stored under a directory called “library” in the R environment. By default, R installs a set of packages during installation. More packages are added later, when they are needed for some specific purpose. When we start the R console, only the default packages are available by default. Other packages which are already installed have to be loaded explicitly to be used by the R program that is going to use them. All the packages available in R language are listed at R Packages. To see a list of all packages installed on your device. library() To see a list of all packages that are currently loaded (note that yours will likely look different). search() ## [1] &quot;.GlobalEnv&quot; &quot;package:maps&quot; &quot;package:knitr&quot; ## [4] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [7] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [10] &quot;Autoloads&quot; &quot;package:base&quot; When adding a new package to our library we only have to install it once. We can do so with the following command. install.packages(&quot;library name&quot;) Alternatively, we can also go to the lower left hand window and select the Packages tab. Then hit the button Install. A dropdown menu will appear where we can search for the package name. Before a package can be used in the code, it must be loaded to the current R environment. You also need to load a package that is already installed previously but not available in the current environment. library(&quot;library name&quot;) For example, suppose we wanted to install and load the package “ggplot2”, (a very popular package for making plots). We would type the following commands. # Install package (only need to do this once) install.packages(&quot;ggplot2&quot;) # Load into working environment (need to do this for each new R session) library(&quot;ggplot2&quot;) It might seem strange to (1) have to download packages tto use features and (2) have to load these packages each time we wish to use them; however, there are several good reasons for doing packages in this way, and this system is considered a feature. We don’t have all possible packages available to us at all times because that is a lot of information that R would need to store at once which could make our computer lag. These packages are also always being updated at different rates with different features. Most users will only utilize packages in CRAN, so having to update R each session for features you may never use would be tedious. Furthermore, there are several packages which contain objects and functions with the same name. 8.1 Namespace Collisions Every time we load a package into our environment the results for the search() function changes. The most recently added package is always listed after the global environment, followed by the second most recent, and so on. The search() function tells us how R searches for an object that we called. For example, consider the following command. v = c(1,2,3) mean(v) ## [1] 2 In this case R is searching for the function mean first in the global environment, and then in the package in the order that appears in the output of the search() function. The package base is always last. In our case the function mean() is only defined in the base package. If you want to call a function from a specific package explicitly and want to be sure there is no confusion you can type the package name followed by :: and the desired command. base::mean(v) ## [1] 2 This can be useful, but is not usually necessary. "],["loops.html", "Chapter 9 Loops 9.1 While Loop 9.2 For Loops 9.3 Break 9.4 Next 9.5 Nested Loops 9.6 Additional Resources", " Chapter 9 Loops Loops are another type of control flow structure. They dictate how many times a series of commands should be run. There are two type of loops, a while loop and a for loop. These two loops operate similarly and are found in other programming languages such as C and Python. 9.1 While Loop A while loop is used when you want to perform a task indefinitely, until a particular condition is met. It’s a condition-controlled loop. The loop will continue until the condition is FALSE. x = 5 # If statement is true, keep running the loop while (x != 0 ) { print(x) x = x - 1 } ## [1] 5 ## [1] 4 ## [1] 3 ## [1] 2 ## [1] 1 If the condition is false at the start, the while loop will never be executed at all. x = 0 # If statement starts as TRUE, the loop will never run while (x != 0 ) { print(x) x = x - 1 } 9.2 For Loops The for statement in R is a bit different from what you usually use in other programming languages. Rather than iterating over a numeric progression, R’s for statement iterates over the items of a vector or a list. The items are iterated in the order that they appear in the vector. # Iterate through a vector colors = c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;) for (x in colors) { print(x) } ## [1] &quot;red&quot; ## [1] &quot;green&quot; ## [1] &quot;blue&quot; ## [1] &quot;yellow&quot; lst = list(3.14, &quot;Hi&quot;, c(1,2,3)) for (i in lst) { print(i) } ## [1] 3.14 ## [1] &quot;Hi&quot; ## [1] 1 2 3 If you need to execute a group of statements for a specified number of times, use sequence operator : or built-in function seq(). # Print &#39;Hello!&#39; 3 times for (x in 1:3) { print(&quot;Hello!&quot;) } ## [1] &quot;Hello!&quot; ## [1] &quot;Hello!&quot; ## [1] &quot;Hello!&quot; for (x in seq(from=2,to=8,by=2)) { print(x^2) } ## [1] 4 ## [1] 16 ## [1] 36 ## [1] 64 9.3 Break The break statement is used to exit the loop immediately. It simply jumps out of the loop altogether, and the program continues after the loop. x = 5 # If statement starts as TRUE, the loop will never run while (x != 0 ) { print(x) x = x - 1 if(x == 2){ print(&quot;Entered IF statement, stop loop&quot;) break } } ## [1] 5 ## [1] 4 ## [1] 3 ## [1] &quot;Entered IF statement, stop loop&quot; If not given an adequate stopping criteria or break statement the loop will continue forever. For example, if we started the above examples at x = -2. The break statement is particularly important for the while loop. The break statement can also be used in a for loop. It simply jumps out of the loop altogether, and the program continues after the loop. colors = c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;) for (x in colors) { if (x == &quot;blue&quot;){ break } print(x) } ## [1] &quot;red&quot; ## [1] &quot;green&quot; The for loops do not have the same risk of “running forever”, like while loops have. 9.4 Next We can also use the next command in both for loops and while loops in order to skip executing a command. for(i in 1:10){ i = i^2 if(i &lt;5){ next } print(i) } ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 ## [1] 100 The code inside the loop will run until it reaches the next statement. Once 9.5 Nested Loops We can also create loops within loops. We refer to creating loops within other loops as a nested loop. for(i in 1:10){ for(j in 1:3){ statement = paste(&quot;i=&quot;, i, &quot;, j=&quot;, j) print(statement) } } ## [1] &quot;i= 1 , j= 1&quot; ## [1] &quot;i= 1 , j= 2&quot; ## [1] &quot;i= 1 , j= 3&quot; ## [1] &quot;i= 2 , j= 1&quot; ## [1] &quot;i= 2 , j= 2&quot; ## [1] &quot;i= 2 , j= 3&quot; ## [1] &quot;i= 3 , j= 1&quot; ## [1] &quot;i= 3 , j= 2&quot; ## [1] &quot;i= 3 , j= 3&quot; ## [1] &quot;i= 4 , j= 1&quot; ## [1] &quot;i= 4 , j= 2&quot; ## [1] &quot;i= 4 , j= 3&quot; ## [1] &quot;i= 5 , j= 1&quot; ## [1] &quot;i= 5 , j= 2&quot; ## [1] &quot;i= 5 , j= 3&quot; ## [1] &quot;i= 6 , j= 1&quot; ## [1] &quot;i= 6 , j= 2&quot; ## [1] &quot;i= 6 , j= 3&quot; ## [1] &quot;i= 7 , j= 1&quot; ## [1] &quot;i= 7 , j= 2&quot; ## [1] &quot;i= 7 , j= 3&quot; ## [1] &quot;i= 8 , j= 1&quot; ## [1] &quot;i= 8 , j= 2&quot; ## [1] &quot;i= 8 , j= 3&quot; ## [1] &quot;i= 9 , j= 1&quot; ## [1] &quot;i= 9 , j= 2&quot; ## [1] &quot;i= 9 , j= 3&quot; ## [1] &quot;i= 10 , j= 1&quot; ## [1] &quot;i= 10 , j= 2&quot; ## [1] &quot;i= 10 , j= 3&quot; Here is an example of a nested loop which changes the elements of matrix to be the product of the row and column location. my_matrix = matrix(NA, nrow = 5, ncol = 5) for(i in 1:nrow(my_matrix)){ for(j in 1:nrow(my_matrix)){ my_matrix[i,j] = i*j } } my_matrix ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 2 4 6 8 10 ## [3,] 3 6 9 12 15 ## [4,] 4 8 12 16 20 ## [5,] 5 10 15 20 25 9.6 Additional Resources Chapter 13 of “R for Programming in Data Science” Videos: Control Flow 6 | while loops Control Flow 7 | while loops Bisection Method Control Flow 8 | infinite while loops Control Flow 9 | for loop Intro Control Flow 10 | break and next Control Flow 11 | nested for loops Programming Loops vs. Recursion - Computerphile "],["apply.html", "Chapter 10 Apply Family of Functions 10.1 apply() 10.2 lapply() 10.3 sapply() 10.4 tapply() 10.5 mapply() 10.6 replicate() 10.7 How to Pick a Method 10.8 More Examples Additional Resources", " Chapter 10 Apply Family of Functions Loops (like for, and while) are a way to repeatedly execute some code. However, they are often slow in execution when it comes to processing large data sets. R has a more efficient and quick approach to perform iterations – The apply family. The apply family consists of vectorized functions. Below are the most common forms of apply functions. apply() lapply() sapply() tapply() mapply() replicate() These functions let you take data in batches and process the whole batch at once. There primary difference is in the object (such as list, matrix, data frame etc.) on which the function is applied to and the object that will be returned from the function. These functions apply a function to different components of a vector/list/dataframe/array in a non-sequential way. In general, if each element in your object is not dependent on the other elements of your object then an apply function is usually faster than a loop. 10.1 apply() The apply()function is used to apply a function to the rows or columns of matrices or data frames. It assembles the returned values into a vector, and then returns that vector. If you want to apply a function on a data frame, make sure that the data frame is homogeneous (i.e. either all numeric values or all character strings) Otherwise, R will force all columns to have identical types. This may not be what you want. In that case, use the lapply() or sapply() functions. Description of the required apply() arguments: X: A matrix , data frame or array MARGIN: A vector giving the subscripts which the function will be applied over. 1 indicates rows 2 indicates columns c(1, 2) indicates rows and columns FUN: The function to be applied # Get column means data = matrix(1:9, nrow=3, ncol=3) data ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 apply(data, 2, mean) ## [1] 2 5 8 # Get row means apply(data, 1, sum) ## [1] 12 15 18 You can use user-defined functions as well. apply(data, 2, function(x){ # Standard deviation formula y = sum(x -mean(x))^2/(length(x)-1) return(y) }) ## [1] 0 0 0 10.2 lapply() The lapply() function is used to apply a function to each element of the list. It collects the returned values into a list, and then returns that list. Description of the required lapply() arguments: X: A matrix , data frame or array FUN: The function to be applied data_lst = list(item1 = 1:5, item2 = seq(4,36,8), item3 = c(1,3,5,7,9)) data_lst ## $item1 ## [1] 1 2 3 4 5 ## ## $item2 ## [1] 4 12 20 28 36 ## ## $item3 ## [1] 1 3 5 7 9 data_vector = c(1,2,3,4,5,6,7,8) data_vector ## [1] 1 2 3 4 5 6 7 8 lapply(data_lst, sum) ## $item1 ## [1] 15 ## ## $item2 ## [1] 100 ## ## $item3 ## [1] 25 lapply(data_vector, sum) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 10.3 sapply() The sapply() and lapply() work basically the same. The only difference is that lapply() always returns a list, whereas sapply() tries to simplify the result into a vector or matrix. If the return value is a list where every element is length 1, you get a vector. If the return value is a list where every element is a vector of the same length (&gt; 1), you get a matrix. If the lengths vary, simplification is impossible and you get a list. Description of the required sapply() arguments: X: A matrix , data frame or array FUN: The function to be applied data_lst = list(item1 = 1:5, item2 = seq(4,36,8), item3 = c(1,3,5,7,9)) data_lst ## $item1 ## [1] 1 2 3 4 5 ## ## $item2 ## [1] 4 12 20 28 36 ## ## $item3 ## [1] 1 3 5 7 9 sapply(data_lst, sum) ## item1 item2 item3 ## 15 100 25 10.4 tapply() The tapply() function breaks the data set up into groups and applies a function to each group. Description of the required sapply() arguments: X: A matrix , data frame or array INDEX: A grouping factor or a list of factors FUN: The function to be applied data = data.frame(name=c(&quot;Amy&quot;,&quot;Max&quot;,&quot;Ray&quot;,&quot;Kim&quot;,&quot;Sam&quot;,&quot;Eve&quot;,&quot;Bob&quot;), age=c(24, 22, 21, 23, 20, 24, 21), gender=factor(c(&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;))) data ## name age gender ## 1 Amy 24 F ## 2 Max 22 M ## 3 Ray 21 M ## 4 Kim 23 F ## 5 Sam 20 M ## 6 Eve 24 F ## 7 Bob 21 M tapply(data$age, data$gender, min) ## F M ## 23 20 10.5 mapply() The mapply() function is a multivariate version of sapply(). It applies FUN to the first elements of each … argument, the second elements, the third elements, and so on. Description of the required mapply() arguments: FUN: The function to be applied ...: Arguments to vectorize over (vectors or lists of strictly positive length, or all of zero length). mapply(rep, times = 1:4, x = 4:1) ## [[1]] ## [1] 4 ## ## [[2]] ## [1] 3 3 ## ## [[3]] ## [1] 2 2 2 ## ## [[4]] ## [1] 1 1 1 1 10.6 replicate() The replicate() function is a wrapper for sapply(). If we want to repeat an evaluation of an function call or an expression that does not require us to iterate through a data set or vector we can use replicate(). Description of the required replicate() arguments: n: An integer containing the number of replications. expr: The expression (or function call) to evaluate repeatedly. replicate(n = 4, &quot;Hello&quot;) ## [1] &quot;Hello&quot; &quot;Hello&quot; &quot;Hello&quot; &quot;Hello&quot; replicate(n = 10, factorial(4)) ## [1] 24 24 24 24 24 24 24 24 24 24 replicate(n = 5, sample(c(&quot;red&quot;, &quot;blue&quot;))) ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;blue&quot; ## [2,] &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; &quot;red&quot; 10.7 How to Pick a Method It can be difficult at first to decide which of these apply function you may want to use. In general, we can use the flow chart below as a quick guide. 10.8 More Examples To see some more examples of these functions in action. We will use the iris data set which is a built in data set in R. This data set has four numeric columns, and one factor column, Species. Each row is a flower, and there are four different measurements of each flower. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Find the maximum value for the numeric variables for each observation. numeric_iris = iris[,-5] max_in_row = apply(numeric_iris, 1, max) head(max_in_row) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 Determine the (arithmetic) mean of the sepal width for each species. mean_species = tapply(iris$Sepal.Width, INDEX = iris$Species, mean) mean_species ## setosa versicolor virginica ## 3.428 2.770 2.974 Determine the (arithmetic) mean and the median of sepal width for each species. my_avgs = function(vec){ the_mean = mean(vec) the_median = median(vec) return_object=c(the_mean, the_median) names(return_object) = c(&quot;mean&quot;, &quot;median&quot;) return(return_object) } species_avgs = tapply(iris$Sepal.Width, iris$Species, my_avgs) species_avgs ## $setosa ## mean median ## 3.428 3.400 ## ## $versicolor ## mean median ## 2.77 2.80 ## ## $virginica ## mean median ## 2.974 3.000 Make a plot of the sepal width and sepal length. Make the points differ depending on the species type. # Starting plot, make it blank plot(iris$Sepal.Length, iris$Sepal.Width, col = &quot;white&quot;) # Custom function to add the points add_points = function(the_data, ...){ if(the_data[5]==&quot;setosa&quot;){ points(x = the_data[1], y = the_data[2], col = &quot;red&quot;, pch = 0) } else if(the_data[5]==&quot;virginica&quot;){ points(x = the_data[1], y = the_data[2], col = &quot;blue&quot;, pch = 2) } else{ points(x = the_data[1], y = the_data[2], col = &quot;green&quot;, pch = 10) } } # Use apply to add points apply(iris, 1, add_points) ## NULL Make a plot of the sepal width and sepal length. Make the points differ depending on the species type. Add the (arithmetic) mean of these two variables for each group. # ------ PLOT FROM BEFORE # Starting plot, make it blank plot(iris$Sepal.Length, iris$Sepal.Width, col = &quot;white&quot;) apply(iris, 1, add_points) ## NULL # ------ # Split the data into a list by factor split_iris = split(iris, f = iris$Species) # Iterate through the list and add (black) points to the plot lapply(split_iris, function(species_data){ points(mean(species_data$Sepal.Length), mean(species_data$Sepal.Width), pch = 16) }) ## $setosa ## NULL ## ## $versicolor ## NULL ## ## $virginica ## NULL Lets try using another example. Suppose we wish to use the following formula (below) with a = Sepal.Length, b = Sepal.Width, and c = Petal.Length. \\[ \\frac{-b + \\sqrt{b^2-4ac} }{2a}\\] Now there is more efficient ways to do this in R, but lets practice how we would do it with mapply as an example. my_formula = function(a, b, c){ num = (-b + sqrt(b^2 + 4*a*c)) den = 2*a answer = num/den return(answer) } formula_results = mapply(my_formula, a = iris$Sepal.Length, b = iris$Sepal.Width, c = iris$Petal.Length) head(formula_results) ## [1] 0.2831638 0.3098526 0.2860609 0.3260870 0.2800000 0.3061340 Additional Resources http://adv-r.had.co.nz/Functionals.html "],["text-data.html", "Chapter 11 Text Data 11.1 Making Strings 11.2 Substring Operations 11.3 Dividing Strings into Vectors 11.4 Converting Objects into Strings 11.5 Versatility of the paste() Function 11.6 gsub , sub 11.7 Text of Some Importance 11.8 Search 11.9 Word Count Tables", " Chapter 11 Text Data In this section we give an introduction to strings and string operations, how to extracting and manipulating string objects, and an introduction to general search methods. We have focus on character objects in particular because a lot of the “messy” data comes in character form. For example, web pages can be scraped, email can be analyzed for network properties and survey responses must be processed and compared. Even if you only care about numbers, it helps to be able to extract them from text and manipulate them easily. In general we will try to stick to the following distinction. However, many people will use the term “character” and “string” interchangeably. Character: a symbol in a written language, specifically what you can enter at a keyboard: letters, numerals, punctuation, space, newlines, etc. &#39;L&#39;, &#39;i&#39;, &#39;n&#39;, &#39;c&#39;, &#39;o&#39;, &#39;l&#39; String: a sequence of characters bound together Lincoln Note: R does not have a separate type for characters and strings class(&quot;L&quot;) ## [1] &quot;character&quot; class(&quot;Lincoln&quot;) ## [1] &quot;character&quot; 11.1 Making Strings Use single or double quotes to construct a string, but in general its recommeded to use double quotes. This is because the R console showcases character strings in double quotes regardless of how the string was created, and sometimes we might have single or double quotes in the string itself. &#39;Lincoln&#39; ## [1] &quot;Lincoln&quot; &quot;Lincoln&quot; ## [1] &quot;Lincoln&quot; &quot;Abraham Lincoln&#39;s Hat&quot; ## [1] &quot;Abraham Lincoln&#39;s Hat&quot; &quot;As Lincoln never said, &#39;Four score and seven beers ago&#39;&quot; ## [1] &quot;As Lincoln never said, &#39;Four score and seven beers ago&#39;&quot; &#39;As Lincoln never said, &quot;Four score and seven beers ago&quot;&#39; ## [1] &quot;As Lincoln never said, \\&quot;Four score and seven beers ago\\&quot;&quot; The space, \" \" is a character; so are multiple spaces \" \" and the empty string, \"\". Some characters are special, so we have “escape characters” to specify them in strings. - quotes within strings: \\\" - tab: \\t - new line \\n and carriage return \\r – use the former rather than the latter when possible. Recall that strings (or character objects) are one of the atomic data types, like numeric or logical. Thus strings can go into scalars, vectors, arrays, lists, or be the type of a column in a data frame. We can use the nchar() to get the length of a single string. length(&quot;Abraham Lincoln&#39;s beard&quot;) ## [1] 1 length(c(&quot;Abraham&quot;, &quot;Lincoln&#39;s&quot;, &quot;beard&quot;)) ## [1] 3 nchar(&quot;Abraham&quot;) ## [1] 7 nchar(&quot;Abraham Lincoln&#39;s beard&quot;) ## [1] 23 nchar(c(&quot;Abraham&quot;, &quot;Lincoln&#39;s&quot;, &quot;beard&quot;)) ## [1] 7 9 5 We can use print() to display the string, and cat() is used to write the string directly to the console. If you’re debugging, message() is R’s preferred syntax. presidents = c(&quot;Fillmore&quot;,&quot;Pierce&quot;,&quot;Buchanan&quot;,&quot;Davis&quot;,&quot;Johnson&quot;) print(&quot;Abraham Lincoln&quot;) ## [1] &quot;Abraham Lincoln&quot; cat(&quot;Abraham Lincoln&quot;) ## Abraham Lincoln cat(presidents) ## Fillmore Pierce Buchanan Davis Johnson message(presidents) ## FillmorePierceBuchananDavisJohnson 11.2 Substring Operations Substring: a smaller string from the big string, but still a string in its own right. A string is not a vector or a list, so we cannot use subscripts like [[ ]] or [ ] to extract substrings; we use substr() instead. phrase &lt;- &quot;Christmas Bonus&quot; substr(phrase, start=8, stop=12) ## [1] &quot;as Bo&quot; We can also use substr to replace elements: substr(phrase, 13, 13) = &quot;g&quot; phrase ## [1] &quot;Christmas Bogus&quot; The function substr() can also be used for vectors. substr() vectorizes over all its arguments: presidents ## [1] &quot;Fillmore&quot; &quot;Pierce&quot; &quot;Buchanan&quot; &quot;Davis&quot; &quot;Johnson&quot; substr(presidents,1,2) # First two characters ## [1] &quot;Fi&quot; &quot;Pi&quot; &quot;Bu&quot; &quot;Da&quot; &quot;Jo&quot; substr(presidents,nchar(presidents)-1,nchar(presidents)) # Last two ## [1] &quot;re&quot; &quot;ce&quot; &quot;an&quot; &quot;is&quot; &quot;on&quot; substr(presidents,20,21) # No such substrings so return the null string ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; substr(presidents,7,7) # Explain! ## [1] &quot;r&quot; &quot;&quot; &quot;a&quot; &quot;&quot; &quot;n&quot; 11.3 Dividing Strings into Vectors strsplit() divides a string according to key characters, by splitting each element of the character vector x at appearances of the pattern split. scarborough.fair = &quot;parsley, sage, rosemary, thyme&quot; strsplit(scarborough.fair, &quot;,&quot;) ## [[1]] ## [1] &quot;parsley&quot; &quot; sage&quot; &quot; rosemary&quot; &quot; thyme&quot; strsplit(scarborough.fair, &quot;, &quot;) ## [[1]] ## [1] &quot;parsley&quot; &quot;sage&quot; &quot;rosemary&quot; &quot;thyme&quot; Pattern is recycled over elements of the input vector: strsplit (c(scarborough.fair, &quot;Garfunkel, Oates&quot;, &quot;Clement, McKenzie&quot;), &quot;, &quot;) ## [[1]] ## [1] &quot;parsley&quot; &quot;sage&quot; &quot;rosemary&quot; &quot;thyme&quot; ## ## [[2]] ## [1] &quot;Garfunkel&quot; &quot;Oates&quot; ## ## [[3]] ## [1] &quot;Clement&quot; &quot;McKenzie&quot; Note that it outputs a list of character vectors. 11.4 Converting Objects into Strings Explicitly converting one variable type to another is called casting. Notice that the number “7.2e12” is printed as supplied, but “7.2e5” is not. This is because if a number is exceeding large, small, or close to zero, then R will by default use scientific notation for that number. as.character(7.2) # Obvious ## [1] &quot;7.2&quot; as.character(7.2e12) # Obvious ## [1] &quot;7.2e+12&quot; as.character(c(7.2,7.2e12)) # Obvious ## [1] &quot;7.2&quot; &quot;7.2e+12&quot; as.character(7.2e5) # Not quite so obvious ## [1] &quot;720000&quot; 11.5 Versatility of the paste() Function The paste() function is very flexible. With one vector argument, works like as.character(). paste(41:45) ## [1] &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; With 2 or more vector arguments, it combines them with recycling. paste(presidents,41:45) ## [1] &quot;Fillmore 41&quot; &quot;Pierce 42&quot; &quot;Buchanan 43&quot; &quot;Davis 44&quot; &quot;Johnson 45&quot; paste(presidents,c(&quot;R&quot;,&quot;D&quot;)) # Not historically accurate! ## [1] &quot;Fillmore R&quot; &quot;Pierce D&quot; &quot;Buchanan R&quot; &quot;Davis D&quot; &quot;Johnson R&quot; paste(presidents,&quot;(&quot;,c(&quot;R&quot;,&quot;D&quot;),41:45,&quot;)&quot;) ## [1] &quot;Fillmore ( R 41 )&quot; &quot;Pierce ( D 42 )&quot; &quot;Buchanan ( R 43 )&quot; ## [4] &quot;Davis ( D 44 )&quot; &quot;Johnson ( R 45 )&quot; We can changing the separator between pasted-together terms. paste(presidents, &quot; (&quot;, 41:45, &quot;)&quot;, sep=&quot;_&quot;) ## [1] &quot;Fillmore_ (_41_)&quot; &quot;Pierce_ (_42_)&quot; &quot;Buchanan_ (_43_)&quot; &quot;Davis_ (_44_)&quot; ## [5] &quot;Johnson_ (_45_)&quot; paste(presidents, &quot; (&quot;, 41:45, &quot;)&quot;, sep=&quot;&quot;) ## [1] &quot;Fillmore (41)&quot; &quot;Pierce (42)&quot; &quot;Buchanan (43)&quot; &quot;Davis (44)&quot; ## [5] &quot;Johnson (45)&quot; We can also condense multiple strings together using the collapse argument. paste(presidents, &quot; (&quot;, 41:45, &quot;)&quot;, sep=&quot;&quot;, collapse=&quot;; &quot;) ## [1] &quot;Fillmore (41); Pierce (42); Buchanan (43); Davis (44); Johnson (45)&quot; Default value of collapse is NULL – that is, it won’t use it. 11.6 gsub , sub gsub is all occurances, and sub is first occurance. 11.7 Text of Some Importance Consider the following quote from Abraham Lincoln. Often times we will want to study or analyze a block of text. To “If we shall suppose that American slavery is one of those offenses which, in the providence of God, must needs come, but which, having continued through His appointed time, He now wills to remove, and that He gives to both North and South this terrible war as the woe due to those by whom the offense came, shall we discern therein any departure from those divine attributes which the believers in a living God always ascribe to Him? Fondly do we hope, fervently do we pray, that this mighty scourge of war may speedily pass away. Yet, if God wills that it continue until all the wealth piled by the bondsman’s two hundred and fifty years of unrequited toil shall be sunk, and until every drop of blood drawn with the lash shall be paid by another drawn with the sword, as was said three thousand years ago, so still it must be said”the judgments of the Lord are true and righteous altogether.\" We can read in the file with the following commands. the_url = &quot;https://raw.githubusercontent.com/rpkgarcia/LearnRBook/main/data_sets/al1.txt&quot; al1 = readLines(the_url, warn = FALSE) # How many lines in the file length(al1) ## [1] 1 # See the first few lines head(al1) ## [1] &quot;If we shall suppose that American slavery is one of those offenses which, in the providence of God, must needs come, but which, having continued through His appointed time, He now wills to remove, and that He gives to both North and South this terrible war as the woe due to those by whom the offense came, shall we discern therein any departure from those divine attributes which the believers in a living God always ascribe to Him? Fondly do we hope, fervently do we pray, that this mighty scourge of war may speedily pass away. Yet, if God wills that it continue until all the wealth piled by the bondsman’s two hundred and fifty years of unrequited toil shall be sunk, and until every drop of blood drawn with the lash shall be paid by another drawn with the sword, as was said three thousand years ago, so still it must be said “the judgments of the Lord are true and righteous altogether”.&quot; al1 is a vector, one element per line of text 11.8 Search We can search through text strings for certain patterns. Some particularly helpful functions for doing this are grep() and grepl(). The grep() function Narrowing down entries: use grep() to find which strings have a matching search term # Returns indices for which element in al1 has the term &quot;God&quot; grep(&quot;God&quot;, al1) ## [1] 1 # Returns T/F values for which indices have the term &quot;God&quot; grepl(&quot;God&quot;, al1) ## [1] TRUE # Returns the the elements in al1 that have the term &quot;God&quot; al1[grep(&quot;God&quot;, al1)] ## [1] &quot;If we shall suppose that American slavery is one of those offenses which, in the providence of God, must needs come, but which, having continued through His appointed time, He now wills to remove, and that He gives to both North and South this terrible war as the woe due to those by whom the offense came, shall we discern therein any departure from those divine attributes which the believers in a living God always ascribe to Him? Fondly do we hope, fervently do we pray, that this mighty scourge of war may speedily pass away. Yet, if God wills that it continue until all the wealth piled by the bondsman’s two hundred and fifty years of unrequited toil shall be sunk, and until every drop of blood drawn with the lash shall be paid by another drawn with the sword, as was said three thousand years ago, so still it must be said “the judgments of the Lord are true and righteous altogether”.&quot; 11.9 Word Count Tables Lets convert all the words in this document into a single string. Then we can al1 = paste(al1, collapse=&quot; &quot;) al1.words = strsplit(al1, split=&quot; &quot;)[[1]] head(al1.words) ## [1] &quot;If&quot; &quot;we&quot; &quot;shall&quot; &quot;suppose&quot; &quot;that&quot; &quot;American&quot; Tabulate how often each word appears using the table() function. Then we can sort the frequencies in order using sort(). wc = table(al1.words) wc = sort(wc,decreasing=TRUE) head(wc,20) ## al1.words ## the of and shall that to we be by those as do drawn ## 9 6 5 4 4 4 4 3 3 3 2 2 2 ## God He in it must said this ## 2 2 2 2 2 2 2 Notice that puncuation using these methods is still present. wc[&quot;years&quot;] ## years ## 2 wc[&quot;years,&quot;] ## &lt;NA&gt; ## NA In addition, all our words and string subsets are case sensitive. # What happens when we look for a word that is not in our # word count table? # words are case sensitive wc[&quot;that&quot;] ## that ## 4 which(names(wc) == &quot;That&quot;) ## integer(0) wc[&quot;That&quot;] ## &lt;NA&gt; ## NA "],["regular-expressions.html", "Chapter 12 Regular Expressions 12.1 Ranges, Escaping 12.2 Metacharacters 12.3 Quantifiers 12.4 Anchoring 12.5 Splitting on a Regexp 12.6 An Example Additional Resources", " Chapter 12 Regular Expressions With basic string-manipulation functions, we saw how to do things like split up entries in a data file which are separated by commas. text = &quot;One Fish, Two Fish, Red Fish, Blue Fish&quot; strsplit(text,split=&quot;,&quot;) ## [[1]] ## [1] &quot;One Fish&quot; &quot; Two Fish&quot; &quot; Red Fish&quot; &quot; Blue Fish&quot; or by single spaces strsplit(text,split=&quot; &quot;) ## [[1]] ## [1] &quot;One&quot; &quot;Fish,&quot; &quot;Two&quot; &quot;Fish,&quot; &quot;Red&quot; &quot;Fish,&quot; &quot;Blue&quot; &quot;Fish&quot; or even a comma followed by a space strsplit(text,split=&quot;, &quot;) ## [[1]] ## [1] &quot;One Fish&quot; &quot;Two Fish&quot; &quot;Red Fish&quot; &quot;Blue Fish&quot; But we don’t know how to deal with situations like splitting on a comma, optionally followed by some number of spaces. Not only is it annoying to have such a simple thing defeat us, it’s an instance of a much broader class of problems. If we’re trying to extract data from webpages, we may want to get rid of all the formatting instructions buried in the source of the webpage. We might want to extract all the personal names from a document which are preceded by titles (such as Mr., Ms., Miss, Dr.), without knowing what those names are, or how long they are. And so forth. We need a language for telling R about patterns of strings. The most basic such language is that of regular expressions. Regular expressions are used to match sets of strings. Start with string constants, and build up by allowing “this and then that”, “either this or that”, “repeat this”, etc. These rules get expressed in a grammar, with special symbols. Every regular expression is a sequence of symbols, which specifies a set of text strings that follow some pattern that — match the regular expression. - Regular expressions are strings and therefore a regexp can be stored in a character variable. This means that regexps can be built up and changed using string-manipulating functions. A valid regular expression must conform to certain rules of grammar; it gets interpreted by the computer as rules for matching certain strings, but not others. Every string is a valid regexp. We say “regexp” as short hand for the phrase a “regular expression as used in R”. fly matches end of “fruitfly”, “why walk when you can fly” but it does not match “time flies like an arrow; fruit flies like a banana; a banana flies poorly”. fly_phrases = c(&quot;fruitfly&quot;, &quot;why walk when you can fly&quot;, &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot;, &quot;superman flew&quot;) # Returns which elements have the term &quot;fly&quot; grep(&quot;fly&quot;, fly_phrases, value = T) ## [1] &quot;fruitfly&quot; &quot;why walk when you can fly&quot; If we did wish to match one regexp OR another regexp we cold use the “|” symbol. This symbol is used in the same way it was in section 1.4 # Returns which elements have the term &quot;fly&quot; or &quot;flies&quot; grep(&quot;fly|flies&quot;, fly_phrases, value = T) ## [1] &quot;fruitfly&quot; ## [2] &quot;why walk when you can fly&quot; ## [3] &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot; # Returns which elements have the term &quot;fly&quot; or &quot;flies&quot; grep(&quot;flies|fly&quot;, fly_phrases, value = T) ## [1] &quot;fruitfly&quot; ## [2] &quot;why walk when you can fly&quot; ## [3] &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot; # Returns which elements have &quot;fly flies&quot; or &quot;time&quot; or &quot;flies&quot; grep(&quot;time|fruit fly|flies&quot;, fly_phrases, value = T) ## [1] &quot;time flies like an arrow; fruit flies like a banana; a banana flies poorly&quot; Parentheses are used to create groups. text_colors = c(&quot;Some people say grey&quot;, &quot;others say gray,&quot;, &quot;and both are greatly used&quot;) # Searches for the same thing grep(&quot;gr(e|a)y&quot;, text_colors, value = T) ## [1] &quot;Some people say grey&quot; &quot;others say gray,&quot; grep(&quot;grey|gray&quot;, text_colors, value = T) ## [1] &quot;Some people say grey&quot; &quot;others say gray,&quot; 12.1 Ranges, Escaping A character class is a list of characters enclosed between [ and ] which matches any single character in that list. We use these braces in regular expressions to indicate character ranges. For example the regexp [0123456789] matches any single digit. text = c(&quot;1 Fish&quot;, &quot;2 Fish&quot;, &quot;red fish&quot;, &quot;blue fish&quot;) # Any numbers? grep(&quot;[0123456789]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; If the first character of the list is the caret ^, then it matches any character not in the list. For example, [^abc] matches anything except the characters a, b or c. # Any letters EXCEPT a, b, c grep(&quot;[^abc]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; &quot;red fish&quot; &quot;blue fish&quot; Another example: t[aeiou] matches any two-character sequence in which “t” is followed by a lowercase vowel. text_baseball = c(&quot;Ohhhhh&quot;, &quot;take me out&quot;, &quot;to the ball game&quot;) # Match any two-character sequence in which “t” is followed by a lowercase vowel. grep(&quot;t[aeiou]&quot;,text_baseball, value = T) ## [1] &quot;take me out&quot; &quot;to the ball game&quot; This system of using ranges is used a lot, and there are certain named classes of characters are predefined, below are some of them. [:lower:] : Lower-case letters, equivalent to [a-z] [:upper:] : Upper-case letters, equivalent to [A-Z] [:alpha:] : Alphabetic characters: [:lower:] and [:upper:]. [:digit:] : Digits: 0 1 2 3 4 5 6 7 8 9, equivalent to [0-9] \\d : digit, equivalent to [:digit:] \\D : Non-digit [:alnum:] : Alphanumeric characters: [:alpha:] and [:digit:]. [:blank:] : Blank characters: space and tab, and possibly other locale-dependent characters such as non-breaking space. [:punct:] : Punctuation characters: ! \" # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~. [:graph:] : Graphical characters: [:alnum:] and [:punct:]. [:space:] : Space characters: tab, newline, vertical tab, form feed, carriage return, space and possibly other locale-dependent characters. \\s : space \\S : not space \\w: word characters, equivalent to [[:alnum:]_] or [A-z0-9]. \\W: not word, equivalent to [^A-z0-9_]. # Are any digits in the text? grep(&quot;[[:digit:]]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; # Are any upper case letters in the text? grep(&quot;[[:upper:]]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; # Are any lower case letters in the text? grep(&quot;[[:lower:]]&quot;, text, value = T) ## [1] &quot;1 Fish&quot; &quot;2 Fish&quot; &quot;red fish&quot; &quot;blue fish&quot; 12.2 Metacharacters The fundamental building blocks are the regular expressions that match a single character. Most characters, including all letters and digits, are regular expressions that match themselves. However, we also use some of these characters to mean different things in order to match more intricate patterns. The characters reserved for special meanings (and not simply as characters to match) are called metacharacters. Any metacharacter with special meaning may be quoted by preceding it with a backslash. The metacharacters in extended regular expressions are . | ( ) [ { ^ $ * + ?. We already saw | and [] in action above. Now lets talk about the . symbol. This symbol matches any single character. To match strings that have a “.” we need to use a backslash. text = c(&quot;There was a monster&quot;, &quot;Superman flew over there.&quot;, &quot;He made it in time.&quot;, &quot;Yumm, pancakes!&quot;, &quot;MMmm Mmmm they were good...&quot;) # Looks for every character grep(&quot;.&quot;, text, value = T) ## [1] &quot;There was a monster&quot; &quot;Superman flew over there.&quot; ## [3] &quot;He made it in time.&quot; &quot;Yumm, pancakes!&quot; ## [5] &quot;MMmm Mmmm they were good...&quot; # Matches only &quot;.&quot; grep(&quot;\\\\.&quot;, text, value = T) ## [1] &quot;Superman flew over there.&quot; &quot;He made it in time.&quot; ## [3] &quot;MMmm Mmmm they were good...&quot; 12.3 Quantifiers Here is a list of some of the metacharacters and some of their features. These are all quantifiers and they control how many times the regexp should be matched. The following features all are considered repetition quantifiers. + : The preceding item will be matched one or more times. * : The preceding item will be matched zero or more times. ? : The preceding item is optional and will be matched at most once. {n} : The preceding item is matched exactly “n” times. {n,} : The preceding item is matched “n” or more times. {n,m} : The preceding item is matched at least “n” times, but not more than “m” times. # Detect the letter &quot;m&quot; grep(&quot;m&quot;, text, value = T) ## [1] &quot;There was a monster&quot; &quot;Superman flew over there.&quot; ## [3] &quot;He made it in time.&quot; &quot;Yumm, pancakes!&quot; ## [5] &quot;MMmm Mmmm they were good...&quot; # Detect the letter &quot;m&quot; exactly one time grep(&quot;m{1}&quot;, text, value = T) ## [1] &quot;There was a monster&quot; &quot;Superman flew over there.&quot; ## [3] &quot;He made it in time.&quot; &quot;Yumm, pancakes!&quot; ## [5] &quot;MMmm Mmmm they were good...&quot; If we want to match a regexp exactly {n}, {n,} or {n,m} times then it looks for this sequence consecutively. For example, the following command does not output “He made it in time.”, despite this phrase having two “m”s in it. # Detect the letter &quot;m&quot; exactly two or more times (in a row) grep(&quot;m{2,}&quot;, text, value = T) ## [1] &quot;Yumm, pancakes!&quot; &quot;MMmm Mmmm they were good...&quot; # Another example text = c(&quot;3, 2, 1, GO!&quot;, &quot;On the count of 3,&quot;, &quot;Count to 100&quot;, &quot;Wish upon 1 star.&quot;) # Detect exactly two digits in a row. grep(&quot;[[:digit:]]{2}&quot;, text, value = T) ## [1] &quot;Count to 100&quot; By default, quantifiers are “greedy” and they match as many repetitions as they can. Following a quantifier by ? makes it match as few as possible. # Only look for one digit then stop. # It doesn&#39;t matter if there is more. grep(&quot;[[:digit:]]?&quot;, text, value = T) ## [1] &quot;3, 2, 1, GO!&quot; &quot;On the count of 3,&quot; &quot;Count to 100&quot; ## [4] &quot;Wish upon 1 star.&quot; 12.4 Anchoring Anchoring is used to find regexps at specific locations in a string. For example, at the beginning or end of a word, or at the beginning or end of a phrase. $ means a pattern can only match at the end of a line or string ^ means (outside of braces) the beginning of a line or string &lt; and &gt; anchor to beginning or ending of words \\b anchors boundary (beginning or ending) of words, \\B anywhere else # matches elements ending in a lower-case letter or comma grep(&quot;[a-z,]$&quot;, text, value = T) ## [1] &quot;On the count of 3,&quot; # matches capital letters not at the beginning or ending of a word grep(&quot;\\\\B[A-Z]&quot;, text, value = T) ## [1] &quot;3, 2, 1, GO!&quot; # Find elements that end with a number grep(&quot;[[:digit:]]$&quot;, text, value = T) ## [1] &quot;Count to 100&quot; # Find elements that start with a number grep(&quot;^[[:digit:]]&quot;, text, value = T) ## [1] &quot;3, 2, 1, GO!&quot; # Find elements that have a word that starts or ends with u grep(&quot;\\\\bu&quot;, text, value = T) ## [1] &quot;Wish upon 1 star.&quot; # Find elements that have a word that starts or ends with t grep(&quot;\\\\bt&quot;, text, value = T) ## [1] &quot;On the count of 3,&quot; &quot;Count to 100&quot; 12.5 Splitting on a Regexp We can use regexps in many R functions, we are not limited to just grep() and grepl. For example, strsplit() will take a regexp as its split argument. This means we can make splits a string into new strings at each instance of the regexp, just like it would if split were a string. # Load data: al2 = readLines(&quot;http://www.stat.cmu.edu/~cshalizi/statcomp/14/lectures/04/al2.txt&quot;) al2 = paste(al2, collapse=&quot; &quot;) # Split words by space al2.words1 = strsplit(al2, split=&quot; &quot;) # Lets see what this looks like head(sort(table(al2.words1))) ## al2.words1 ## - &quot;the &quot;Woe absorbs accept achieve ## 1 1 1 1 1 1 # Split words by space or by a punctuation symbol al2.words2 = strsplit(al2, split=&quot;(\\\\s|[[:punct:]])+&quot;)[[1]] head(sort(table(al2.words2))) ## al2.words2 ## absorbs accept achieve against agents aid ## 1 1 1 1 1 1 Closer examination shows there’s still a problem: “men’s” \\(\\rightarrow\\) “men”, “s”. To handle possessives: look for any number of white spaces, or at least one punctuation mark followed by at least one space al2.words3 = strsplit(al2, split=&quot;\\\\s+|([[:punct:]]+[[:space:]]+)&quot;)[[1]] head(sort(table(al2.words3))) ## al2.words3 ## &quot;the &quot;Woe absorbs accept achieve ## 1 1 1 1 1 1 12.6 An Example grep() scans a character vector for matches to a regexp returns either indices of matches, or matching strings grep(x, pattern, value) Example: scanning data files ANSS.csv.html catalogs earthquakes of magnitude 6+, 1/1/2002–1/1/2012 &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;NCEDC_Search_Results&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;Your search parameters are:&lt;ul&gt; &lt;li&gt;catalog=ANSS &lt;li&gt;start_time=2002/01/01,00:00:00 &lt;li&gt;end_time=2012/01/01,00:00:00 &lt;li&gt;minimum_magnitude=6.0 &lt;li&gt;maximum_magnitude=10 &lt;li&gt;event_type=E &lt;/ul&gt; &lt;PRE&gt; DateTime,Latitude,Longitude,Depth,Magnitude,MagType,NbStations,Gap,Distance,RMS,Source,EventID 2002/01/01 10:39:06.82,-55.2140,-129.0000,10.00,6.00,Mw,78,,,1.07,NEI,2002010140 Now we work on extracting just the data, not the search parameters and so forth. Notice that every line of data begins with a date, YYYY/MM/DD. We can use this to find just the part of the data that we want. anss = readLines(&quot;http://www.stat.cmu.edu/~cshalizi/statcomp/14/lectures/05/ANSS.csv.html&quot;, warn=FALSE) initial_date = &quot;^[0-9]{4}/[0-9]{2}/[0-9]{2}&quot; head(grep(x=anss,pattern=initial_date,value=TRUE)) ## [1] &quot;2002/01/01 10:39:06.82,-55.2140,-129.0000,10.00,6.00,Mw,78,,,1.07,NEI,2002010140&quot; ## [2] &quot;2002/01/01 11:29:22.73,6.3030,125.6500,138.10,6.30,Mw,236,,,0.90,NEI,2002010140&quot; ## [3] &quot;2002/01/02 14:50:33.49,-17.9830,178.7440,665.80,6.20,Mw,215,,,1.08,NEI,2002010240&quot; ## [4] &quot;2002/01/02 17:22:48.76,-17.6000,167.8560,21.00,7.20,Mw,427,,,0.90,NEI,2002010240&quot; ## [5] &quot;2002/01/03 07:05:27.67,36.0880,70.6870,129.30,6.20,Mw,431,,,0.87,NEI,2002010340&quot; ## [6] &quot;2002/01/03 10:17:36.30,-17.6640,168.0040,10.00,6.60,Mw,386,,,1.14,NEI,2002010340&quot; We can also use the invert option to find the non-matches. grep(x=anss,pattern=initial_date,invert=TRUE,value=TRUE) ## [1] &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;NCEDC_Search_Results&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;Your search parameters are:&lt;ul&gt;&quot; ## [2] &quot;&lt;li&gt;catalog=ANSS&quot; ## [3] &quot;&lt;li&gt;start_time=2002/01/01,00:00:00&quot; ## [4] &quot;&lt;li&gt;end_time=2012/01/01,00:00:00&quot; ## [5] &quot;&lt;li&gt;minimum_magnitude=6.0&quot; ## [6] &quot;&lt;li&gt;maximum_magnitude=10&quot; ## [7] &quot;&lt;li&gt;event_type=E&quot; ## [8] &quot;&lt;/ul&gt;&quot; ## [9] &quot;&lt;PRE&gt;&quot; ## [10] &quot;DateTime,Latitude,Longitude,Depth,Magnitude,MagType,NbStations,Gap,Distance,RMS,Source,EventID&quot; ## [11] &quot;&lt;/PRE&gt;&quot; ## [12] &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot; 12.6.1 Match Locations and Substrings When you just want a Boolean vector saying where the matches are use grepl(). grepl(x=anss,pattern=initial_date)[1:20] ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can also consider the function regexpr() which returns location of first match in the target string, plus attributes like length of matching substring. The function gregexpr() is similar, but it returns a list of this for all matches. A location of -1 means no match, and neither returns the text of the match x = c(&quot;A and B&quot;, &quot;A, B and C&quot;, &quot;A, B, C and D&quot;, &quot;foobar&quot;) pattern = &quot;[[:space:]]*(,|and)[[:space:]]&quot; # Match data from regexpr() regexpr(pattern, x) ## [1] 2 2 2 -1 ## attr(,&quot;match.length&quot;) ## [1] 5 2 2 -1 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE # Match data from gregexpr() gregexpr(pattern, x) ## [[1]] ## [1] 2 ## attr(,&quot;match.length&quot;) ## [1] 5 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE ## ## [[2]] ## [1] 2 5 ## attr(,&quot;match.length&quot;) ## [1] 2 5 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE ## ## [[3]] ## [1] 2 5 8 ## attr(,&quot;match.length&quot;) ## [1] 2 2 5 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE ## ## [[4]] ## [1] -1 ## attr(,&quot;match.length&quot;) ## [1] -1 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE To getting the matching text we can use regmatches() which takes the output of regexpr() or gregexpr() and a string, and returns the matching strings. x = c(&quot;A and B&quot;, &quot;A, B and C&quot;, &quot;A, B, C and D&quot;, &quot;foobar&quot;) pattern = &quot;[[:space:]]*(,|and)[[:space:]]&quot; ## Match data from regexpr() m = regexpr(pattern, x) regmatches(x, m) ## [1] &quot; and &quot; &quot;, &quot; &quot;, &quot; regmatches(x, m, invert = TRUE) ## [[1]] ## [1] &quot;A&quot; &quot;B&quot; ## ## [[2]] ## [1] &quot;A&quot; &quot;B and C&quot; ## ## [[3]] ## [1] &quot;A&quot; &quot;B, C and D&quot; ## ## [[4]] ## [1] &quot;foobar&quot; ## Match data from gregexpr() m = gregexpr(pattern, x) regmatches(x, m) ## [[1]] ## [1] &quot; and &quot; ## ## [[2]] ## [1] &quot;, &quot; &quot; and &quot; ## ## [[3]] ## [1] &quot;, &quot; &quot;, &quot; &quot; and &quot; ## ## [[4]] ## character(0) regmatches(x, m, invert = TRUE) ## [[1]] ## [1] &quot;A&quot; &quot;B&quot; ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## [[3]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ## ## [[4]] ## [1] &quot;foobar&quot; Why separate regexpr() from regmatches? This lets us do things like count the number or length of matches with less work. It also lets us see what text in one file corresponds to matching locations in another file. Get the (latitude, longitude) pair for each earthquake. one_geo_coord = paste(&quot;-?[0-9]+\\\\.[0-9]{4}&quot;) pair_geo_coords = paste(rep(one_geo_coord,2),collapse=&quot;,&quot;) have_coords = grepl(x=anss,pattern=pair_geo_coords) coord.matches = gregexpr(pattern=pair_geo_coords,text=anss[have_coords]) coords = regmatches(x=anss[have_coords],m=coord.matches) head(coords) ## [[1]] ## [1] &quot;-55.2140,-129.0000&quot; ## ## [[2]] ## [1] &quot;6.3030,125.6500&quot; ## ## [[3]] ## [1] &quot;-17.9830,178.7440&quot; ## ## [[4]] ## [1] &quot;-17.6000,167.8560&quot; ## ## [[5]] ## [1] &quot;36.0880,70.6870&quot; ## ## [[6]] ## [1] &quot;-17.6640,168.0040&quot; coord.matches[1] ## [[1]] ## [1] 24 ## attr(,&quot;match.length&quot;) ## [1] 18 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE coords =unlist(coords) # De-list-ify to vector coord.pairs = strsplit(coords,&quot;,&quot;) # Break apart latitude and longitude coord.df = do.call(rbind, coord.pairs) # De-list-ify to array coord.df = apply(coord.df,2,as.numeric) # Character to numeric coord.df = as.data.frame(coord.df) colnames(coord.df) = c(&quot;Latitude&quot;,&quot;Longitude&quot;) head(coord.df) ## Latitude Longitude ## 1 -55.214 -129.000 ## 2 6.303 125.650 ## 3 -17.983 178.744 ## 4 -17.600 167.856 ## 5 36.088 70.687 ## 6 -17.664 168.004 library(maps) map(&quot;world&quot;) points(x=coord.df$Longitude, y=coord.df$Latitude, pch=19, col=&quot;red&quot;) 12.6.2 Replacements Assigning to regmatches() changes the matched string, just like substr() sub() and gsub() work like regexpr() and gregexpr(), but with an extra replace argument sub() produces a new string, assigning to regmatches() modifies the original one Really, assigning to regmatches() creates a new string, destroys the old one, and assigns the new string the old name. Additional Resources “Begining Computer Science with R” Chapter 12 R Help Page on Regular Expressions "],["simulation.html", "Chapter 13 Simulation 13.1 What Are Simulation Studies 13.2 Review Random Variables 13.3 Generating Random Variables 13.4 Setting a Seed 13.5 sample() 13.6 replicate() 13.7 Adding curves to graphs 13.8 Example: Central Limit Theorem (CLT)", " Chapter 13 Simulation 13.1 What Are Simulation Studies Simulation studies are used in statistics to verify theoretical results, and to do “what-if” experiments. The are commonly used in a variety of applications and fields. Often times we have a particular theory or an idea about how things work. In order to verify that our theory is correct we can simulate a data set with known properties, and then check if the data set matches our theory. For example, suppose you want to calculate a 95% confidence interval for the heights of all college students. Our theory on confidence intervals says that we expect that a 95% confidence interval will capture the true mean about 95% of the time. If we simply go out and take a sample of data from “real-life” and then calculate the a confidence interval we have no idea if that confidence interval captures the truth because the true average height of all college students is unknown! It is not feasible to sample every college students, so we will never know if the true mean actually falls within our interval. Furthermore, in this example we only calculated one confidence interval. If we did know the true mean then our results would simply indicate that the confidence interval captured the mean or not, but nothing about the rate that confidence intervals capture the mean, which should be 95%. What we can do instead is simulate this process. We can randomly generate data that has a true mean of \\(\\mu\\) using a computer. Then we can estimate a 95% confidence interval using the appropriate methods and see if this confidence interval contains \\(\\mu\\). We then can repeat this process as many times as we would like because we are using a computer, which makes the process much simpler. If our theory about confidence intervals is correct we would expect that 95% of our confidence intervals captured the true mean (\\(\\mu\\)), and the rest did not. Simulations are very important, and can range greatly in complexity. We will focus on simple techniques in this section. For a more complete discussion on simulation studies in statistics, and best practices see Morris, White, and Crowther (2019). This article is freely avaliable online at https://onlinelibrary.wiley.com/doi/10.1002/sim.8086. 13.2 Review Random Variables Before discussing how to simulate data with specific properties we review the concept of a random variable. This discussion is adapted primarily from Chapter 3 and 4 of Diez, Cetinkaya-Rundel, and Barr (2020). A random variable is a random process or variable with a numeric outcome. Random variables in general have a typical value which is called the expected value. However, in practice random variables also have variability, that is we do not expect to obtain the expected value for every random variable. Instead we expect to observe a range of values according to some sort of pattern, which is usually centered around the expected value. For example, in Yellowstone National Park, Wyoming there is a famous geyser called Old Faithful. A geyser is a natural hot spring that periodically erupts water. The amount of time (in minutes) the eruption lasts varies each time, but not by a dramatic amount. The eruption time in minutes is the random variable, and the expected value is the average eruption length, and we can measure the variability using a measure of dispersion, like the variance. Below is a histogram of a random sample of eruptions times of 272 different eruptions. hist(faithful$eruptions, main = &quot;Eruption Times of Old Faithful&quot;, xlab = &quot;Time (in minutes)&quot;, breaks = seq(0, 7, by = .5)) As mentioned previously, random variables generate observations according to some sort of pattern. These patterns are referred to as densities, and can be analyzed visually, and analytically (i.e. through formulas). One of the most common ways to look at how often we would expect certain values for data that we find from the “real-world” is to use a histogram. Histogram order observations into mutually exclusive bins, where the height of each bin indicates how common a particular range of values is. For example, in the histogram above each bin is a 30 second (0.5 minute) range, and we can see the frequency of observations within the data set that are in this range on the y-axis. When thinking about random variables though, it is often more helpful to look at the proportion of observed values within a bin, instead of the frequency. We can modify our histogram to accomplish this. hist(faithful$eruptions, main = &quot;Eruption Times of Old Faithful&quot;, xlab = &quot;Time (in minutes)&quot;, breaks = seq(0, 7, by = .5), freq = FALSE) Notice that the y-axis now says “Density”. This is the relative probability that an observed data point will be a particular value. In “real-world” data, we can only estimate the density. We will never know the truth. Hence, we will never know the true expected value, or the true variance. This is why we have statistics!! We have statistics in order to make educated guesses about these values and properties from which the data arises from. Analyzing the density or pattern of a random variable visually with histograms is intuitive, but limiting. Using a formula as a representation for a density is much more versatile and useful. For these functions we have parameters which are values that let us further customize the function representation of a density to the specific random variable that we have. Let \\(X\\) be a random variable, and \\(x\\) be some observed value. In practice, if \\(X\\) is a random variable that can only take on values that are discrete (usually integers) then we say the probability of observing some a particular value, say \\(x\\), is denoted \\(p(x)\\). There are extremely well known discrete densities that random variables tend to follow and that are available in R. A few of them are listed below. Binomial: \\[p(x) = \\binom{n}{x} p^x (1-p)^{n-x} \\hspace{1cm} x = 0, ..., n\\] Poison: \\[p(x) = λ^x exp(-λ)/x! \\hspace{1cm} x = 0, ..., n\\] Negative Binomial: \\[Γ(x+n)/(Γ(n) x!) p^n (1-p)^x \\hspace{1cm} x = 0, ..., \\] If \\(X\\) is a random variable that can be any value within a range of numbers then we denote the density function of this random variable by \\(f(x)\\). As with discrete random variables, there are extremely well known continuous densities that random variables tend to follow and that are available in R. A few of them are listed below. Uniform: \\[f(x) = 1/(max-min)\\] Log-Normal: \\[f(x) = 1/(√(2 π) σ x) e^{-((log{(x)} - μ)^2 / (2 σ^2))} \\hspace{1cm} 0 &lt;x &lt; \\infty\\] Exponential: \\[f(x) = λ {e}^{- λ x} \\hspace{1cm} 0 &lt;x &lt; \\infty\\] Normal: \\[f(x) = 1/(√(2 π) σ) e^{-((x - μ)^2/(2 σ^2))} \\hspace{1cm} -\\infty &lt;x &lt; \\infty\\] t-Distribution \\[f(x) = Γ((n+1)/2) / (√(n π) Γ(n/2)) (1 + x^2/n)^-((n+1)/2)\\hspace{1cm} -\\infty &lt;x &lt; \\infty\\] To see a complete list of well known distribution functions (or densities) that R already has see the help file ?Distributions. 13.3 Generating Random Variables Each distribution available in base R is listed in ?Distributions. Each of the distributions has a link to their corresponding help file which lists four main functions: dxxx(), pxxx(), qxxx() and rxxx(). These are the density function, cumulative distribution function, quantile function, and a random number generator for the particular random variable of interest. The letters xxx are replaced by an code for the particular random variable. The density function (dxxx()) generates the relative probability of observing a particular value. The cumulative distribution function (pxxx()) generates the probability of observing a particular value, and anything smaller than this value. The quantile function (qxxx()) generates what value corresponds to a given percentile. Lastly, the random number generator (rxxx()) will generate a random variable according to the given distribuiton/density. We will focus only on dxxx() and rxxx(). For example, go to ?Distributions and click on dnorm which corresponds to the normal distribution (in the bottom third of the list). Here you will see the functions dnorm(), pnorm(), qnorm(), and rnorm(). To generate a normal random variable with mean 0 and standard deviation 1 we can use the following command. # Generate a single normal random variable with mean 0 and standard deviation 1 rnorm(1) ## [1] -0.1049144 # Generate 20 normal random variables with mean 0 and standard deviation 1 rnorm(20) ## [1] -1.392449727 1.018245804 0.826401081 1.289595050 -0.643231482 ## [6] -0.001173311 -1.948468606 0.680949495 0.274233523 -1.905682922 ## [11] -1.207395634 0.379645715 -0.832700980 -1.480467865 1.045205002 ## [16] 1.203374466 1.143497941 -0.798450844 0.713542224 0.014509402 However, as we saw in the previous section, these common distribution functions have parameters which let us further customize the behavior of the random variable. We can change the parameters of any of the distributions in R using the function arguments. # Normal random variable with mean 10, and standard deviation 0.5 rnorm(1, mean = 10, sd = 0.5) ## [1] 10.53266 # Normal random variable with mean 10, and standard deviation 0.5 rnorm(20, mean = 10, sd = 0.5) ## [1] 9.918810 9.633491 10.141749 9.903283 10.774333 10.138772 9.615449 ## [8] 10.785818 10.650341 10.024944 9.791361 10.094124 10.505912 10.409901 ## [15] 10.263248 9.263302 9.656979 9.812624 10.574604 10.154701 To find the relative probability of observing a particular value for a normal distribution we use dnorm(). # Relative probability of observing the value 0.25 # for a normal random variable with mean 0 and standard devation 1 dnorm(0.25) ## [1] 0.3866681 # Relative probability of observing the value 0.25, -0.5, 2 # for a normal random variable with mean 0 and standard devation 1 dnorm(c(0.25, -0.5, 2)) ## [1] 0.38666812 0.35206533 0.05399097 13.4 Setting a Seed Often times when running a simulation we will want to use the same numbers over and over again. The function rxxx() generates values randomly though, which means each time we call this function we will get new and different values. In order to make sure our values are consistent each time we run R, or across computers we can set the seed. The seed determines the way the computer generates our random numbers. Normally the seed is random, so each time rxxx() is called we get a new random sequence. Using the set.seed() function will make sure that the sequence stays the same each time we run rxxx(). See the example below were generate a sequence of 10 uniform random variables that are between -5 and 5. If you copy this code directly into your computer you will get the same sequence. However, if you do not set the seed you will get a different sequence. set.seed(1) runif(10, min = -5, max = 5) ## [1] -2.3449134 -1.2787610 0.7285336 4.0820779 -2.9831807 3.9838968 ## [7] 4.4467527 1.6079779 1.2911404 -4.3821373 13.5 sample() The sample() function is a powerful tool that can let you create your own unique random sequence. You can sample values with replacement, or without replacement. You can also assign certain probabilities to certain events. This is a particularly helpful function for rearranging rows, and for generating a sequence of categorical variables. For example, we can simulate a coin flip. sample(c(&quot;Heads&quot;, &quot;Tails&quot;), size=1 , prob = c(0.5, 0.5)) ## [1] &quot;Tails&quot; Below is the code for simulating 10 coin flips. sample(c(&quot;Heads&quot;, &quot;Tails&quot;), size=10 , prob = c(0.5, 0.5), replace = TRUE) ## [1] &quot;Tails&quot; &quot;Heads&quot; &quot;Tails&quot; &quot;Heads&quot; &quot;Tails&quot; &quot;Heads&quot; &quot;Heads&quot; &quot;Tails&quot; &quot;Heads&quot; ## [10] &quot;Heads&quot; 13.6 replicate() The replicate() function repeats a function call n times in a very efficient way. Suppose we wish to find the probability we get exactly 3 heads if we flip a coin 10 times. We can replicate flipping a coin 10 times, and count how many of these times we see exactly 3 heads. coin_flip_heads3 = function(){ coin_flip = sample(c(&quot;Heads&quot;, &quot;Tails&quot;), size=10 , prob = c(0.5, 0.5), replace = TRUE) num_heads = length(which(coin_flip == &quot;Heads&quot;)) if(num_heads == 3){ heads3 = TRUE } else{ heads3 = FALSE } return(heads3) } # Generates flipping a coin 3 times # Returns TRUE if exactly 3 flips resulted in heads # Returns FALSE if otherwise coin_flip_heads3() ## [1] FALSE # Replicate the experiment 10,000 times see_heads3 = replicate(10000, coin_flip_heads3()) # How many of these experiments results in 3 heads??? # Probability of seeing exactly 3 heads is approximately 12% table(see_heads3)/10000 ## see_heads3 ## FALSE TRUE ## 0.8857 0.1143 13.7 Adding curves to graphs Often times when generating data or using a real-world data set we might want to see how well a well known distribution fits a particular data set. We can do so by adding the proposed density function on to a histogram which contains the data set of interest. For example, suppose we wish to see if a normal distribution with mean of 3.5 and standard deviation of 1.14 fits the old faithful data set for eruption times. We can add this density function on top and see if it approximately fits the data. hist(faithful$eruptions, main = &quot;Eruption Times of Old Faithful&quot;, xlab = &quot;Time (in minutes)&quot;, breaks = seq(0, 7, by = .5), freq = FALSE) curve(dnorm(x, 3.5, 1.14), add = TRUE) Now lets generate 272 normal random variables with mean 3.5 and standard deviation of 1.14 and see how well are generated data matches the density function. gen_data = rnorm(272, mean = 3.5, sd = 1.14) hist(gen_data, main = &quot;Simulated Data&quot;, xlab = &quot;X&quot;, breaks = seq(-0.5, 7, by = .5), freq = FALSE) curve(dnorm(x, 3.5, 1.14), add = TRUE) We do not see a perfect fit, but this is what happens with random samples. The fit for the simulated data is what we expect approximately if we had a sample with this distribution. It should be approximately the same as the curve, which we see for the simulated data. Our old faithful data is significantly less fitted the simulated data. Thus it appears that the old faithful eruption times is probably not normally distributed with mean 3.5 and standard deviation 1.14. How similar is “similar enough” is not a hard and fast rule, and it is ultimately up to the researcher. The simulated data set gives us a general idea of what is “similar enough”. Note that the curve() function does not need to be added to graph but can stand alone. curve(dnorm(x, 3.5, 1.14), 0, 7, add = FALSE) In addition, we can make our own functions to plot using curve(). my_fun = function(x){ y = x^2 + 2*x - 3 return(y) } curve(my_fun(x), -10, 10) 13.8 Example: Central Limit Theorem (CLT) 13.8.1 Recall CLT Let \\(X_1, ..., X_n\\) be independent and identically distributed random variables with mean and variance, \\(\\mu\\) and \\(\\sigma^2\\). If the sample size is sufficiently large (\\(n \\geq 30\\)), the sample mean \\(\\bar{x}\\) will tend to follow a normal distribution with mean \\(\\mu\\) and standard deviation \\(\\frac{\\sigma}{\\sqrt{n}}\\). In other words, for any set of data \\(X_1, ..., X_n\\) that is independent and comes from the same distribution, and that distribution has a finite mean and variance, \\(\\mu\\) and \\(\\sigma^2\\). Then \\[\\bar{x} \\sim N \\left ( \\mu, \\frac{\\sigma}{\\sqrt{n}} \\right ) \\] The distribution above is a sampling distribution. It is the distribution of a sample mean. That is, if we take \\(k\\) samples, and for each sample we calculated the mean, the central limit theorem tells us about the distribution of these means (\\(\\bar{x}_1, \\dots, \\bar{x}_k\\)). 13.8.2 Assumption Violations of CLT The central limit theorem has a few key assumptions. Some of these assumptions are fairly easy to meet, and others are more susceptible to being violated. For example, typically it is reasonable to assume that mean and variance are finite. Other assumptions are easier to violate, and the consequences of violating these assumptions vary greatly. Sometimes we may have data that comes from a mix of multiple distributions, violating the assumption that data is identically distributed. Another assumption violation could be independence. For example, in time series data we typically observe a random variable over a sequence of time and measure it repeatedly. This would violate the independence assumption because earlier observations are typically related to future observations. Another assumption that is often violated is the minimum sample size. The central limit theorem says we need at least 30 observations, or else we should use the t-distribution instead. Historically this is usually not a very big problem. The requirement that our sample size is at least 30 is a “rule of thumb” and not based on rigorous statistical theory. 13.8.3 The Data We will see how well the CLT theorem applies to a data set that has a uniform distribution. That is, say we have a sample of 50 observations which we believe are all uniformly distributed between -5 and 5. We want to determine if the mean of a sample of this type would be normally distributed according to the CLT. To do so, we simulate a sample of this type 10,000 times and assess if it matches the CLT results. # Simulate a sample of 50 observations that are uniformly distributed gen_unif_mean = function(the_min, the_max){ gen_data = runif(50, the_min, the_max) the_mean = mean(gen_data) return(the_mean) } # Simulate 10000 samples, each of size 50, where the minumum value is -5 # And the maximum value is 5 set.seed(123) sim_means = replicate(10000, gen_unif_mean(the_min = -5, the_max=5)) # histogram of results hist(sim_means, freq = FALSE) To add a curve to the graph we need to know the mean and the standard deviation of the data we generated. For a uniform distribution with a minimum of -5 and a maximum of 5, the mean is 0 and the standard deviation is \\(10/\\sqrt{12} \\approx 2.89\\). Thus according to CLT, we expect our histogram above to correspond to a normal density with mean 0 and standard deviation \\(2.89/\\sqrt{50} \\approx 0.41\\). # histogram of results hist(sim_means, freq = FALSE) # Add normal curve according to CLT curve(dnorm(x, mean = 0, sd = 0.41), add = TRUE) References "],["plyr.html", "Chapter 14 plyr 14.1 Tidyverse and plyr 14.2 Iteration with plyr 14.3 Syntax 14.4 Inputs 14.5 Outputs 14.6 Helpers 14.7 Examples 14.8 Comparing Base R, Loops, plyr", " Chapter 14 plyr 14.1 Tidyverse and plyr For this document you will need to install and load the family the package plyr functions. To install the package refer to Section 8. library(plyr) The tidyverse is a collection of packages that share a unique underlying philosophy, frame work, and syntax. There are approximately 20 tidyverse packages, but the core ones are ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, and forcats. You can install these packages individually or all at once using by simply using the command install.packages(\"tidyverse\"). We will be focusing on the plyr package for now. The functions and topics that we that we will be covering can be found in Wickham (2011). 14.2 Iteration with plyr The main focus of the plyr package is to formalize cleaning, and implementing functions to our data sets. In many data sets we have to split the data into the desired subsets, apply a function, and then reformat the data with adjustments. This process appears over and over again. When we apply or implement a function to different components of a data set we typically use an apply method or for loops, Sections 10 and 9 respectively. Often times this can take several lines of code to accomplish. The plyr package aims to reduce the amount of steps it takes to accomplish these tasks. In general, the functions in the plyr package are considered iteration techniques and are closely related to the apply functions in base R. In some cases, a plyr preforms exactly the same as the apply functions, both in terms of efficiency and in the task accomplished. Although the plyr package contains similar functions to base R, some users find this plyr functions to be more intuitive. In addition, the plyr functions generally have more features and can simplify code. The techniques in the plyr package are known as the split-apply-combine method. They work to split a data set in the desired way, apply the desired function, and combine and return the desired output to the user all in one step. This philosophy of the plyr functions is inspired by Google’s map-reduce technique of analyzing their data sets. 14.3 Syntax For the plyr package an array includes the special cases of vectors (1d arrays) and matrices (2d arrays). Arrays are made out of any atomic vector: logical, character, integer, or numeric. A list is a non-atomic array, which is is an array that can contain any type of data structure. A data frame is a 2d array where each column can be a different atomic class. The functions of the plyr package have the same general structure: ?*ply(). All plyr functions have simple and informative names, the first (?) and second (*) characters describe the input and output data types, respectively. Several inputs and outputs are supported: a = array, d = data frame, l = list, and _ = discarded. first character (input type): a, d, l second character (output type): a, d, l, _ (nothing) A table of the 12 core functions is directly below. Similarly to the apply functions, the functions have two or three main arguments depending on the input. a*ply(.data, .margins, .fun, ...) d*ply(.data, .variables, .fun, ...) l*ply(.data, .fun, ...) The first argument .data contains the object that will be split, processed, and recombined. The second argument .variables or .margins describes how to split up the input into pieces. The third argument .fun is the processing function that is to be applied to each piece. The tidyverse uses function arguments to start with a “.” in order to differentiate the plyr arguments with any arguments to be passed to the processing function (.fun). In general, the plyr functions have a very similar set up to the apply functions in base R. Recall apply(ARRAY, MARGIN, FUN). 14.4 Inputs Each input type has various rules for how to split it up. Arrays are sliced by dimension into lower-dimensional pieces. Data frames are subsetted by combinations of variables Each element of a list is separated. The way each input is split up actually doesn’t depend on the class of the data object, but the method that it responds to. For example, an object split using a*ply() must respond to dim() and accept multidimensional indexing. Thus, you can use a data frame as a data input for a*ply(). For d*ply(), the data must work with split() and must be able to be converted into a list. Hence, many matrix objects can be used as inputs for d*ply(). For l*ply() the data must work with length() and [[ indexing. 14.4.1 Input: a*ply() For the a*ply() functions we have .margins argument which works the same as the MARGIN argument for apply(). .margins=1: Slice up into rows. .margins=2: Slice up into columns. .margins=c(1,2): Slice up into individual cells. my_mat = matrix(1:100, nrow = 10) my_mat ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 11 21 31 41 51 61 71 81 91 ## [2,] 2 12 22 32 42 52 62 72 82 92 ## [3,] 3 13 23 33 43 53 63 73 83 93 ## [4,] 4 14 24 34 44 54 64 74 84 94 ## [5,] 5 15 25 35 45 55 65 75 85 95 ## [6,] 6 16 26 36 46 56 66 76 86 96 ## [7,] 7 17 27 37 47 57 67 77 87 97 ## [8,] 8 18 28 38 48 58 68 78 88 98 ## [9,] 9 19 29 39 49 59 69 79 89 99 ## [10,] 10 20 30 40 50 60 70 80 90 100 aaply(my_mat, 2, mean) ## 1 2 3 4 5 6 7 8 9 10 ## 5.5 15.5 25.5 35.5 45.5 55.5 65.5 75.5 85.5 95.5 14.4.2 Input: d*ply() When using a data frame we typically want to split the data into groups based on combinations of variables. We can do this using the .variables argument. This argument supports multiple forms of input. We can use a character vector of column names, c(\"Var1\", \"Var2\") or use .(var1, var2). For example, to find the number of observations that have the same vs and am in the mtcars data set, we can use the following commands daply(mtcars, .variables = c(&quot;vs&quot;, &quot;am&quot;), .fun = nrow) ## am ## vs 0 1 ## 0 12 6 ## 1 7 7 daply(mtcars, .variables = .(vs, am), .fun = nrow) ## am ## vs 0 1 ## 0 12 6 ## 1 7 7 14.4.3 Input: l*ply() Lists do not have an additional argument to break up the data. The function is simply applied to each element of the list. # Input: List, Output: Matrix(array) laply(1:10, rep, times = 4) ## 1 2 3 4 ## [1,] 1 1 1 1 ## [2,] 2 2 2 2 ## [3,] 3 3 3 3 ## [4,] 4 4 4 4 ## [5,] 5 5 5 5 ## [6,] 6 6 6 6 ## [7,] 7 7 7 7 ## [8,] 8 8 8 8 ## [9,] 9 9 9 9 ## [10,] 10 10 10 10 # Input: list, Output: list llply(1:10, rep, times = 4) ## [[1]] ## [1] 1 1 1 1 ## ## [[2]] ## [1] 2 2 2 2 ## ## [[3]] ## [1] 3 3 3 3 ## ## [[4]] ## [1] 4 4 4 4 ## ## [[5]] ## [1] 5 5 5 5 ## ## [[6]] ## [1] 6 6 6 6 ## ## [[7]] ## [1] 7 7 7 7 ## ## [[8]] ## [1] 8 8 8 8 ## ## [[9]] ## [1] 9 9 9 9 ## ## [[10]] ## [1] 10 10 10 10 14.5 Outputs The output type defines how the data is recombined after the processing function, and how the data is labeled. 14.6 Helpers The plyr package has several different “helper” features that are common for data analysis problems. arrange: re-order the rows of a data frame by specifying the columns to order by mutate: add new columns or modifying existing columns, like transform, but new columns can refer to other columns that you just created. summarise: like mutate but create a new data frame, not preserving any columns in the old data frame. join : an adapation of merge which is more similar to SQL, and has a much faster implementation if you only want to find the first match. colwise: make any function work colwise on a dataframe count: quickly count unique combinations and return return as a data frame. failwith: sets a default value to return if the function throws an error. For example, failwith(NA, f) will return an NA whenever f throws an error. The progress: allows you to monitor the progress of long running operations. There four different options: “none”, the default, no progress bar is displayed “text”, provides a textual progress bar. “win” and “tk” provide graphical progress bars for 14.7 Examples We will use the baseball data set in the plyr package. head(baseball) ## id year stint team lg g ab r h X2b X3b hr rbi sb cs bb so ibb ## 1 aaronha01 1954 1 ML1 NL 122 468 58 131 27 6 13 69 2 2 28 39 NA ## 2 aaronha01 1955 1 ML1 NL 153 602 105 189 37 9 27 106 3 1 49 61 5 ## 3 aaronha01 1956 1 ML1 NL 153 609 106 200 34 14 26 92 2 4 37 54 6 ## 4 aaronha01 1957 1 ML1 NL 151 615 118 198 27 6 44 132 1 1 57 58 15 ## 5 aaronha01 1958 1 ML1 NL 153 601 109 196 34 4 30 95 4 1 59 49 16 ## 6 aaronha01 1959 1 ML1 NL 154 629 116 223 46 7 39 123 8 0 51 54 17 ## hbp sh sf gidp cyear ## 1 3 6 4 13 1 ## 2 3 7 4 20 2 ## 3 2 5 7 21 3 ## 4 0 0 3 13 4 ## 5 1 0 3 21 5 ## 6 4 0 9 19 6 What we will explore is the performance of a batter over his career. Creating New Columns in a Data Set To get started, we need to calculate the “career year”, i.e. the number of years since the player started playing. baseball = ddply(baseball, .(id), cyear = year - min(year) + 1) head(baseball) ## id year stint team lg g ab r h X2b X3b hr rbi sb cs bb so ibb ## 1 aaronha01 1954 1 ML1 NL 122 468 58 131 27 6 13 69 2 2 28 39 NA ## 2 aaronha01 1955 1 ML1 NL 153 602 105 189 37 9 27 106 3 1 49 61 5 ## 3 aaronha01 1956 1 ML1 NL 153 609 106 200 34 14 26 92 2 4 37 54 6 ## 4 aaronha01 1957 1 ML1 NL 151 615 118 198 27 6 44 132 1 1 57 58 15 ## 5 aaronha01 1958 1 ML1 NL 153 601 109 196 34 4 30 95 4 1 59 49 16 ## 6 aaronha01 1959 1 ML1 NL 154 629 116 223 46 7 39 123 8 0 51 54 17 ## hbp sh sf gidp cyear ## 1 3 6 4 13 1 ## 2 3 7 4 20 2 ## 3 2 5 7 21 3 ## 4 0 0 3 13 4 ## 5 1 0 3 21 5 ## 6 4 0 9 19 6 Find the number of total home runs for each year, append it to the existing data set. hr_total_year = ddply(baseball, # Starting data set &quot;year&quot;, # How to break up the data set transform, # Make a new column to original data set total.hr = sum(hr)) # New column is the total num of home runs in a year. head(hr_total_year) ## id year stint team lg g ab r h X2b X3b hr rbi sb cs bb so ibb hbp ## 1 ansonca01 1871 1 RC1 25 120 29 39 11 3 0 16 6 2 2 1 NA NA ## 2 forceda01 1871 1 WS3 32 162 45 45 9 4 0 29 8 0 4 0 NA NA ## 3 mathebo01 1871 1 FW1 19 89 15 24 3 1 0 10 2 1 2 0 NA NA ## 4 startjo01 1871 1 NY2 33 161 35 58 5 1 1 34 4 2 3 0 NA NA ## 5 suttoez01 1871 1 CL1 29 128 35 45 3 7 3 23 3 1 1 0 NA NA ## 6 whitede01 1871 1 CL1 29 146 40 47 6 5 1 21 2 2 4 1 NA NA ## sh sf gidp cyear total.hr ## 1 NA NA NA 1 7 ## 2 NA NA NA 1 7 ## 3 NA NA NA 1 7 ## 4 NA NA NA 1 7 ## 5 NA NA NA 1 7 ## 6 NA NA NA 1 7 Add several new columns to a data set with the mutate option. add_columns = ddply(baseball, # inputted data set &quot;year&quot;, # How to split data mutate, # Want original data set with (1+) new columns mu = mean(hr), # New column #1 sigma = sd(hr), # New column #2 cv = sigma/mu) # New column #3 head(add_columns) ## id year stint team lg g ab r h X2b X3b hr rbi sb cs bb so ibb hbp ## 1 ansonca01 1871 1 RC1 25 120 29 39 11 3 0 16 6 2 2 1 NA NA ## 2 forceda01 1871 1 WS3 32 162 45 45 9 4 0 29 8 0 4 0 NA NA ## 3 mathebo01 1871 1 FW1 19 89 15 24 3 1 0 10 2 1 2 0 NA NA ## 4 startjo01 1871 1 NY2 33 161 35 58 5 1 1 34 4 2 3 0 NA NA ## 5 suttoez01 1871 1 CL1 29 128 35 45 3 7 3 23 3 1 1 0 NA NA ## 6 whitede01 1871 1 CL1 29 146 40 47 6 5 1 21 2 2 4 1 NA NA ## sh sf gidp cyear mu sigma cv ## 1 NA NA NA 1 1 1.154701 1.154701 ## 2 NA NA NA 1 1 1.154701 1.154701 ## 3 NA NA NA 1 1 1.154701 1.154701 ## 4 NA NA NA 1 1 1.154701 1.154701 ## 5 NA NA NA 1 1 1.154701 1.154701 ## 6 NA NA NA 1 1 1.154701 1.154701 Creating a New Data Set From the Original Using the baseball teams from 2006, find the number of home runs per team. # Subset data to only look at the year 2006 baseball2006 = subset(baseball, year == 2006) # Split data frame into chunks by year and team ddply(baseball2006, c(&quot;year&quot;, &quot;team&quot;), summarize, # Create new data set to summarize results homeruns = sum(hr)) # New column in the data set ## year team homeruns ## 1 2006 ARI 35 ## 2 2006 ATL 7 ## 3 2006 BAL 19 ## 4 2006 BOS 35 ## 5 2006 CHA 43 ## 6 2006 CHN 26 ## 7 2006 CIN 30 ## 8 2006 CLE 6 ## 9 2006 COL 1 ## 10 2006 DET 15 ## 11 2006 HOU 23 ## 12 2006 KCA 24 ## 13 2006 LAN 17 ## 14 2006 MIL 9 ## 15 2006 MIN 8 ## 16 2006 NYA 19 ## 17 2006 NYN 74 ## 18 2006 OAK 39 ## 19 2006 PHI 8 ## 20 2006 PIT 18 ## 21 2006 SDN 32 ## 22 2006 SEA 11 ## 23 2006 SFN 65 ## 24 2006 SLN 20 ## 25 2006 TBA 0 ## 26 2006 TEX 12 ## 27 2006 TOR 12 ## 28 2006 WAS 0 How many years did each baseball player play. id_num_years = ddply(baseball, # Data set &quot;id&quot;, # How to Split Data summarize, # Create new data frame with results length(year)) # How many values are in each split subset of data head(id_num_years) ## id ..1 ## 1 aaronha01 23 ## 2 abernte02 17 ## 3 adairje01 15 ## 4 adamsba01 19 ## 5 adamsbo03 15 ## 6 adcocjo01 17 Generate a new data frame that contains each player, the number of years they played, and the number of teams the played on. id_years_teams = ddply(baseball, # Data set &quot;id&quot;, # How to split up the data set summarise, # Generate a new data frame for results duration = max(year) - min(year),# New column called duration nteams = length(unique(team))) # New column called nteams Base R Plotting with plyr You can also plot with plyr. # Subset the data set baseball2005_2007 = subset(baseball, year&gt;=2005) # Plot a histogram for each year par(mfrow = c(1, 3)) d_ply(baseball2005_2007, &quot;year&quot;, transform, hist(hr, main = unique(year))) par(mfrow = c(1, 1)) Using your own function You can create your own custom function with plyr just like we did with the apply functions. some_stats = function(player_data){ if(max(player_data$cyear) &gt;=10){ superstar = TRUE } else{ superstar = FALSE } if(max(player_data$hr)&gt;50){ hrstar = TRUE } else{ hrstar = FALSE } return_me = c(superstar, hrstar) names(return_me) = c(&quot;MVP&quot;, &quot;Hitter&quot;) return(return_me) } new_variables = ddply(baseball, # Data set &quot;id&quot;, # Break up data set by player some_stats) new_variables ## id MVP Hitter ## 1 aaronha01 TRUE FALSE ## 2 abernte02 TRUE FALSE ## 3 adairje01 TRUE FALSE ## 4 adamsba01 TRUE FALSE ## 5 adamsbo03 TRUE FALSE ## 6 adcocjo01 TRUE FALSE ## 7 agostju01 TRUE FALSE ## 8 aguilri01 TRUE FALSE ## 9 aguirha01 TRUE FALSE ## 10 ainsmed01 TRUE FALSE ## 11 alexado01 TRUE FALSE ## 12 alexape01 TRUE FALSE ## 13 allendi01 TRUE FALSE ## 14 allenet01 TRUE FALSE ## 15 allenjo02 TRUE FALSE ## 16 almonbi01 TRUE FALSE ## 17 alomaro01 TRUE FALSE ## 18 alomasa01 TRUE FALSE ## 19 alomasa02 TRUE FALSE ## 20 aloufe01 TRUE FALSE ## 21 alouje01 TRUE FALSE ## 22 alouma01 TRUE FALSE ## 23 aloumo01 TRUE FALSE ## 24 altroni01 TRUE FALSE ## 25 alvarwi01 TRUE FALSE ## 26 amesre01 TRUE FALSE ## 27 anderbr01 TRUE FALSE ## 28 anderjo01 TRUE FALSE ## 29 anderla02 TRUE FALSE ## 30 ansonca01 TRUE FALSE ## 31 aparilu01 TRUE FALSE ## 32 appieke01 TRUE FALSE ## 33 applepe01 TRUE FALSE ## 34 applilu01 TRUE FALSE ## 35 ashburi01 TRUE FALSE ## 36 ashbyal01 TRUE FALSE ## 37 ashbyan01 TRUE FALSE ## 38 assenpa01 TRUE FALSE ## 39 astacpe01 TRUE FALSE ## 40 ausmubr01 TRUE FALSE ## 41 austiji01 TRUE FALSE ## 42 azcuejo01 TRUE FALSE ## 43 baergca01 TRUE FALSE ## 44 bagweje01 TRUE FALSE ## 45 bahnsst01 TRUE FALSE ## 46 bailebo01 TRUE FALSE ## 47 baileed01 TRUE FALSE ## 48 baineha01 TRUE FALSE ## 49 bairdo01 TRUE FALSE ## 50 bakerdu01 TRUE FALSE ## 51 bakerfl01 TRUE FALSE ## 52 bancrda01 TRUE FALSE ## 53 bandosa01 TRUE FALSE ## 54 bankser01 TRUE FALSE ## 55 bannifl01 TRUE FALSE ## 56 barbest01 TRUE FALSE ## 57 barrysh01 TRUE FALSE ## 58 bartedi01 TRUE FALSE ## 59 basske01 TRUE FALSE ## 60 baylodo01 TRUE FALSE ## 61 becklja01 TRUE FALSE ## 62 bedrost01 TRUE FALSE ## 63 belanma01 TRUE FALSE ## 64 belchti01 TRUE FALSE ## 65 bellbu01 TRUE FALSE ## 66 bellda01 TRUE FALSE ## 67 bellgu01 TRUE FALSE ## 68 bellira01 TRUE FALSE ## 69 bellja01 TRUE FALSE ## 70 benchjo01 TRUE FALSE ## 71 bendech01 TRUE FALSE ## 72 benesan01 TRUE FALSE ## 73 beniqju01 TRUE FALSE ## 74 benitar01 TRUE FALSE ## 75 bennech01 TRUE FALSE ## 76 bentola01 TRUE FALSE ## 77 bentoru01 TRUE FALSE ## 78 berenju01 TRUE FALSE ## 79 bergmda01 TRUE FALSE ## 80 bergmo01 TRUE FALSE ## 81 berrayo01 TRUE FALSE ## 82 bevacku01 TRUE FALSE ## 83 bicheda01 TRUE FALSE ## 84 bielemi01 TRUE FALSE ## 85 biggicr01 TRUE FALSE ## 86 biittla01 TRUE FALSE ## 87 blackbu02 TRUE FALSE ## 88 blairpa01 TRUE FALSE ## 89 blasido01 TRUE FALSE ## 90 bluegos01 TRUE FALSE ## 91 bluevi01 TRUE FALSE ## 92 blylebe01 TRUE FALSE ## 93 boddimi01 TRUE FALSE ## 94 boggswa01 TRUE FALSE ## 95 bondsba01 TRUE TRUE ## 96 bondsbo01 TRUE FALSE ## 97 bonilbo01 TRUE FALSE ## 98 boonebo01 TRUE FALSE ## 99 boonebr01 TRUE FALSE ## 100 boonera01 TRUE FALSE ## 101 bordepa01 TRUE FALSE ## 102 bordimi01 TRUE FALSE ## 103 bosleth01 TRUE FALSE ## 104 bottoji01 TRUE FALSE ## 105 boudrlo01 TRUE FALSE ## 106 bowala01 TRUE FALSE ## 107 bowerfr01 TRUE FALSE ## 108 boyercl02 TRUE FALSE ## 109 boyerke01 TRUE FALSE ## 110 braunst01 TRUE FALSE ## 111 bresnro01 TRUE FALSE ## 112 bressru01 TRUE FALSE ## 113 brettge01 TRUE FALSE ## 114 brettke01 TRUE FALSE ## 115 breweji01 TRUE FALSE ## 116 bridgto01 TRUE FALSE ## 117 brilene01 TRUE FALSE ## 118 brinked01 TRUE FALSE ## 119 brocklo01 TRUE FALSE ## 120 brookhu01 TRUE FALSE ## 121 broutda01 TRUE FALSE ## 122 browncl01 TRUE FALSE ## 123 brownge01 TRUE FALSE ## 124 brownha01 TRUE FALSE ## 125 brownke01 TRUE FALSE ## 126 brownmo01 TRUE FALSE ## 127 brownol02 TRUE FALSE ## 128 brownpe01 TRUE FALSE ## 129 brownto01 TRUE FALSE ## 130 brunato01 TRUE FALSE ## 131 brunege01 TRUE FALSE ## 132 bucknbi01 TRUE FALSE ## 133 buhlbo01 TRUE FALSE ## 134 buhneja01 TRUE FALSE ## 135 bunniji01 TRUE FALSE ## 136 burbada01 TRUE FALSE ## 137 burdele01 TRUE FALSE ## 138 burdoja01 TRUE FALSE ## 139 burgesm01 TRUE FALSE ## 140 burgmto01 TRUE FALSE ## 141 burkeje01 TRUE FALSE ## 142 burkejo03 TRUE FALSE ## 143 burksel01 TRUE FALSE ## 144 burnije01 TRUE FALSE ## 145 burnsge01 TRUE FALSE ## 146 burnsge02 TRUE FALSE ## 147 burrira01 TRUE FALSE ## 148 burroje01 TRUE FALSE ## 149 busbyji01 TRUE FALSE ## 150 bushdo01 TRUE FALSE ## 151 bushgu01 TRUE FALSE ## 152 bushjo01 TRUE FALSE ## 153 butlebr01 TRUE FALSE ## 154 byrneto01 TRUE FALSE ## 155 cabelen01 TRUE FALSE ## 156 caldwmi01 TRUE FALSE ## 157 callijo01 TRUE FALSE ## 158 caminke01 TRUE FALSE ## 159 campabe01 TRUE FALSE ## 160 campbbi02 TRUE FALSE ## 161 candejo01 TRUE FALSE ## 162 candito01 TRUE FALSE ## 163 cansejo01 TRUE FALSE ## 164 carbobe01 TRUE FALSE ## 165 cardejo02 TRUE FALSE ## 166 cardele01 TRUE FALSE ## 167 cardwdo01 TRUE FALSE ## 168 carewro01 TRUE FALSE ## 169 careyma01 TRUE FALSE ## 170 carlsha01 TRUE FALSE ## 171 carltst01 TRUE FALSE ## 172 carrocl02 TRUE FALSE ## 173 cartega01 TRUE FALSE ## 174 cartejo01 TRUE FALSE ## 175 cartyri01 TRUE FALSE ## 176 cashno01 TRUE FALSE ## 177 castivi02 TRUE FALSE ## 178 cavarph01 TRUE FALSE ## 179 cedence01 TRUE FALSE ## 180 cepedor01 TRUE FALSE ## 181 ceronri01 TRUE FALSE ## 182 cervbo01 TRUE FALSE ## 183 ceyro01 TRUE FALSE ## 184 chambch01 TRUE FALSE ## 185 chancfr01 TRUE FALSE ## 186 chapmbe01 TRUE FALSE ## 187 charlno01 TRUE FALSE ## 188 chaseha01 TRUE FALSE ## 189 cicoted01 TRUE FALSE ## 190 cirilje01 TRUE FALSE ## 191 clancji01 TRUE FALSE ## 192 clarkfr01 TRUE FALSE ## 193 clarkja01 TRUE FALSE ## 194 clarkwi02 TRUE FALSE ## 195 claytro01 TRUE FALSE ## 196 clemeja01 TRUE FALSE ## 197 clemero01 TRUE FALSE ## 198 clemero02 TRUE FALSE ## 199 clinety01 TRUE FALSE ## 200 cobbty01 TRUE FALSE ## 201 coffmdi01 TRUE FALSE ## 202 colavro01 TRUE FALSE ## 203 colbrgr01 TRUE FALSE ## 204 colemjo05 TRUE FALSE ## 205 colesda01 TRUE FALSE ## 206 collida02 TRUE FALSE ## 207 collied01 TRUE FALSE ## 208 colliji01 TRUE FALSE ## 209 collish01 TRUE FALSE ## 210 conceda01 TRUE FALSE ## 211 coneda01 TRUE FALSE ## 212 coninje01 TRUE FALSE ## 213 connoro01 TRUE FALSE ## 214 cookde01 TRUE FALSE ## 215 coonejo01 TRUE FALSE ## 216 coopece01 TRUE FALSE ## 217 coopewa01 TRUE FALSE ## 218 coopewi01 TRUE FALSE ## 219 corcoto01 TRUE FALSE ## 220 cordewi01 TRUE FALSE ## 221 cormirh01 TRUE FALSE ## 222 covinwe01 TRUE FALSE ## 223 cramedo01 TRUE FALSE ## 224 crandde01 TRUE FALSE ## 225 crawfsa01 TRUE FALSE ## 226 crawfwi01 TRUE FALSE ## 227 crigelo01 TRUE FALSE ## 228 cronijo01 TRUE FALSE ## 229 crosefr01 TRUE FALSE ## 230 crossla01 TRUE FALSE ## 231 crossmo01 TRUE FALSE ## 232 crowlte01 TRUE FALSE ## 233 cruzjo01 TRUE FALSE ## 234 cuccito01 TRUE FALSE ## 235 cuellmi01 TRUE FALSE ## 236 curtijo01 TRUE FALSE ## 237 cuyleki01 TRUE FALSE ## 238 dahlebi01 TRUE FALSE ## 239 dahlgba01 TRUE FALSE ## 240 dalyto01 TRUE FALSE ## 241 darkal01 TRUE FALSE ## 242 darliro01 TRUE FALSE ## 243 darwida01 TRUE FALSE ## 244 daubeja01 TRUE FALSE ## 245 daultda01 TRUE FALSE ## 246 daussho01 TRUE FALSE ## 247 davalvi01 TRUE FALSE ## 248 davisch01 TRUE FALSE ## 249 daviscu01 TRUE FALSE ## 250 daviser01 TRUE FALSE ## 251 davisge01 TRUE FALSE ## 252 davisha01 TRUE FALSE ## 253 davisma01 TRUE FALSE ## 254 davissp01 TRUE FALSE ## 255 davisst02 TRUE FALSE ## 256 davisto02 TRUE FALSE ## 257 daviswi02 TRUE FALSE ## 258 dawsoan01 TRUE FALSE ## 259 decindo01 TRUE FALSE ## 260 dejesiv01 TRUE FALSE ## 261 delahed01 TRUE FALSE ## 262 delahji01 TRUE FALSE ## 263 deleojo01 TRUE FALSE ## 264 delgaca01 TRUE FALSE ## 265 dempsri01 TRUE FALSE ## 266 dennyje01 TRUE FALSE ## 267 derripa01 TRUE FALSE ## 268 dickebi01 TRUE FALSE ## 269 dicksmu01 TRUE FALSE ## 270 dietrbi01 TRUE FALSE ## 271 dilonmi01 TRUE FALSE ## 272 doakbi01 TRUE FALSE ## 273 donovbi01 TRUE FALSE ## 274 donovdi01 TRUE FALSE ## 275 donovpa01 TRUE FALSE ## 276 dooinre01 TRUE FALSE ## 277 doolami01 TRUE FALSE ## 278 downial01 TRUE FALSE ## 279 downibr01 TRUE FALSE ## 280 doyleja01 TRUE FALSE ## 281 doylela01 TRUE FALSE ## 282 drabomo01 TRUE FALSE ## 283 driesda01 TRUE FALSE ## 284 dropowa01 TRUE FALSE ## 285 duceyro01 TRUE FALSE ## 286 duffyhu01 TRUE FALSE ## 287 duganjo01 TRUE FALSE ## 288 duncama01 TRUE FALSE ## 289 dunstsh01 TRUE FALSE ## 290 durocle01 TRUE FALSE ## 291 dwyerji01 TRUE FALSE ## 292 dykesji01 TRUE FALSE ## 293 easleda01 TRUE FALSE ## 294 easlemi01 TRUE FALSE ## 295 eckerde01 TRUE FALSE ## 296 edmonji01 TRUE FALSE ## 297 ehmkeho01 TRUE FALSE ## 298 eisenji01 TRUE FALSE ## 299 elberki01 TRUE FALSE ## 300 elliobo01 TRUE FALSE ## 301 ellisdo01 TRUE FALSE ## 302 ellswdi01 TRUE FALSE ## 303 elybo01 TRUE FALSE ## 304 embreal01 TRUE FALSE ## 305 ennisde01 TRUE FALSE ## 306 ericksc01 TRUE FALSE ## 307 etchean01 TRUE FALSE ## 308 evansda01 TRUE FALSE ## 309 evansdw01 TRUE FALSE ## 310 evereca01 TRUE FALSE ## 311 eversho01 TRUE FALSE ## 312 eversjo01 TRUE FALSE ## 313 ewingbu01 TRUE FALSE ## 314 faberre01 TRUE FALSE ## 315 facero01 TRUE FALSE ## 316 fairlro01 TRUE FALSE ## 317 farredu01 TRUE FALSE ## 318 farretu01 TRUE FALSE ## 319 fasseje01 TRUE FALSE ## 320 fellebo01 TRUE FALSE ## 321 fergujo01 TRUE FALSE ## 322 fernasi01 TRUE FALSE ## 323 fernato01 TRUE FALSE ## 324 ferreri01 TRUE FALSE ## 325 ferrewe01 TRUE FALSE ## 326 fettemi01 TRUE FALSE ## 327 fieldce01 TRUE TRUE ## 328 fingero01 TRUE FALSE ## 329 finlech01 TRUE FALSE ## 330 finlest01 TRUE FALSE ## 331 finnelo01 TRUE FALSE ## 332 fisheed02 TRUE FALSE ## 333 fiskca01 TRUE FALSE ## 334 fitzsfr01 TRUE FALSE ## 335 flagsir01 TRUE FALSE ## 336 flahejo01 TRUE FALSE ## 337 flanami01 TRUE FALSE ## 338 fletcda01 TRUE FALSE ## 339 fletcsc01 TRUE FALSE ## 340 floodcu01 TRUE FALSE ## 341 floydcl01 TRUE FALSE ## 342 foileha01 TRUE FALSE ## 343 foleyto02 TRUE FALSE ## 344 foliti01 TRUE FALSE ## 345 forceda01 TRUE FALSE ## 346 fordho01 TRUE FALSE ## 347 fordwh01 TRUE FALSE ## 348 foremfr01 TRUE FALSE ## 349 fornimi01 TRUE FALSE ## 350 forscbo01 TRUE FALSE ## 351 forscke01 TRUE FALSE ## 352 forstte01 TRUE FALSE ## 353 fostege01 TRUE TRUE ## 354 fournja01 TRUE FALSE ## 355 foxne01 TRUE FALSE ## 356 foxxji01 TRUE TRUE ## 357 francjo01 TRUE FALSE ## 358 francju01 TRUE FALSE ## 359 francti01 TRUE FALSE ## 360 frasech01 TRUE FALSE ## 361 freehbi01 TRUE FALSE ## 362 freesge02 TRUE FALSE ## 363 fregoji01 TRUE FALSE ## 364 frencla01 TRUE FALSE ## 365 freylo01 TRUE FALSE ## 366 fribebe01 TRUE FALSE ## 367 frienbo01 TRUE FALSE ## 368 friscfr01 TRUE FALSE ## 369 frymawo01 TRUE FALSE ## 370 furilca01 TRUE FALSE ## 371 gaettga01 TRUE FALSE ## 372 gagnegr01 TRUE FALSE ## 373 galanau01 TRUE FALSE ## 374 galaran01 TRUE FALSE ## 375 galehde01 TRUE FALSE ## 376 galvipu01 TRUE FALSE ## 377 gamblos01 TRUE FALSE ## 378 gantnji01 TRUE FALSE ## 379 gantro01 TRUE FALSE ## 380 ganzech01 TRUE FALSE ## 381 garbege01 TRUE FALSE ## 382 gardnla01 TRUE FALSE ## 383 garneph01 TRUE FALSE ## 384 garvene01 TRUE FALSE ## 385 garvest01 TRUE FALSE ## 386 gehrich01 TRUE FALSE ## 387 gehrilo01 TRUE FALSE ## 388 gerbewa01 TRUE FALSE ## 389 gerhajo01 TRUE FALSE ## 390 geronce01 TRUE FALSE ## 391 gibbojo01 TRUE FALSE ## 392 gibsobo01 TRUE FALSE ## 393 gibsoki01 TRUE FALSE ## 394 ginsbjo01 TRUE FALSE ## 395 girarjo01 TRUE FALSE ## 396 giustda01 TRUE FALSE ## 397 glassja01 TRUE FALSE ## 398 glavito02 TRUE FALSE ## 399 gleaski01 TRUE FALSE ## 400 gomezch02 TRUE FALSE ## 401 gonzaal01 TRUE FALSE ## 402 gonzaju03 TRUE FALSE ## 403 gonzalu01 TRUE TRUE ## 404 gonzami01 TRUE FALSE ## 405 gonzato01 TRUE FALSE ## 406 goodedw01 TRUE FALSE ## 407 goodmbi01 TRUE FALSE ## 408 goodwto01 TRUE FALSE ## 409 gordoto01 TRUE FALSE ## 410 gorege01 TRUE FALSE ## 411 gosligo01 TRUE FALSE ## 412 gossari01 TRUE FALSE ## 413 gottji01 TRUE FALSE ## 414 gowdyha01 TRUE FALSE ## 415 gracema01 TRUE FALSE ## 416 graffto01 TRUE FALSE ## 417 grantmu01 TRUE FALSE ## 418 greenle01 TRUE FALSE ## 419 greensh01 TRUE FALSE ## 420 grichbo01 TRUE FALSE ## 421 griffal01 TRUE FALSE ## 422 griffcl01 TRUE FALSE ## 423 griffke01 TRUE FALSE ## 424 griffke02 TRUE TRUE ## 425 griffto02 TRUE FALSE ## 426 grimebu01 TRUE FALSE ## 427 grimmch01 TRUE FALSE ## 428 grimsja01 TRUE FALSE ## 429 grissma02 TRUE FALSE ## 430 groatdi01 TRUE FALSE ## 431 grohhe01 TRUE FALSE ## 432 gromest01 TRUE FALSE ## 433 groombu01 TRUE FALSE ## 434 grossgr01 TRUE FALSE ## 435 grosske01 TRUE FALSE ## 436 groteje01 TRUE FALSE ## 437 grothjo01 TRUE FALSE ## 438 grovele01 TRUE FALSE ## 439 grubbjo01 TRUE FALSE ## 440 guarded01 TRUE FALSE ## 441 guerrpe01 TRUE FALSE ## 442 guilloz01 TRUE FALSE ## 443 gullibi01 TRUE FALSE ## 444 gumbeha01 TRUE FALSE ## 445 gurala01 TRUE FALSE ## 446 guthrma01 TRUE FALSE ## 447 gwynnto01 TRUE FALSE ## 448 hackst01 TRUE FALSE ## 449 haddiha01 TRUE FALSE ## 450 hadlebu01 TRUE FALSE ## 451 haineje01 TRUE FALSE ## 452 hairsje01 TRUE FALSE ## 453 halldi01 TRUE FALSE ## 454 hallmbi01 TRUE FALSE ## 455 hamilda02 TRUE FALSE ## 456 hamilea01 TRUE FALSE ## 457 hammoje01 TRUE FALSE ## 458 hamnegr01 TRUE FALSE ## 459 hanseda01 TRUE FALSE ## 460 hansero02 TRUE FALSE ## 461 hardeme01 TRUE FALSE ## 462 harnipe01 TRUE FALSE ## 463 harpebr01 TRUE FALSE ## 464 harpeto01 TRUE FALSE ## 465 harrato01 TRUE FALSE ## 466 harrebu01 TRUE FALSE ## 467 harrigr01 TRUE FALSE ## 468 harrile01 TRUE FALSE ## 469 hartnga01 TRUE FALSE ## 470 hassero01 TRUE FALSE ## 471 hasslan01 TRUE FALSE ## 472 hatchbi01 TRUE FALSE ## 473 hattogr01 TRUE FALSE ## 474 hayesch01 TRUE FALSE ## 475 hayesfr01 TRUE FALSE ## 476 haywora01 TRUE FALSE ## 477 heathcl01 TRUE FALSE ## 478 heathje01 TRUE FALSE ## 479 heathmi02 TRUE FALSE ## 480 hebneri01 TRUE FALSE ## 481 heganji01 TRUE FALSE ## 482 heganmi01 TRUE FALSE ## 483 heilmha01 TRUE FALSE ## 484 heldwo01 TRUE FALSE ## 485 helliri01 TRUE FALSE ## 486 helmsto01 TRUE FALSE ## 487 hemslro01 TRUE FALSE ## 488 hendeda01 TRUE FALSE ## 489 hendeke01 TRUE FALSE ## 490 henderi01 TRUE FALSE ## 491 hendrge01 TRUE FALSE ## 492 henrybi01 TRUE FALSE ## 493 herbera01 TRUE FALSE ## 494 hermabi01 TRUE FALSE ## 495 hernajo01 TRUE FALSE ## 496 hernake01 TRUE FALSE ## 497 hernaro01 TRUE FALSE ## 498 herrto01 TRUE FALSE ## 499 hershor01 TRUE FALSE ## 500 herzobu01 TRUE FALSE ## 501 hickmch01 TRUE FALSE ## 502 higbeki01 TRUE FALSE ## 503 higgipi01 TRUE FALSE ## 504 hillejo01 TRUE FALSE ## 505 hillgl01 TRUE FALSE ## 506 hillke01 TRUE FALSE ## 507 hillma01 TRUE FALSE ## 508 hinespa01 TRUE FALSE ## 509 hitchst01 TRUE FALSE ## 510 hoagmy01 TRUE FALSE ## 511 hodgegi01 TRUE FALSE ## 512 hoeftbi01 TRUE FALSE ## 513 hoernjo01 TRUE FALSE ## 514 hoffmtr01 TRUE FALSE ## 515 hofmaso01 TRUE FALSE ## 516 hollato01 TRUE FALSE ## 517 holmeda01 TRUE FALSE ## 518 holtzke01 TRUE FALSE ## 519 honeyri01 TRUE FALSE ## 520 hoopeha01 TRUE FALSE ## 521 hootobu01 TRUE FALSE ## 522 hoppjo01 TRUE FALSE ## 523 hornsro01 TRUE FALSE ## 524 hortowi01 TRUE FALSE ## 525 houghch01 TRUE FALSE ## 526 howarel01 TRUE FALSE ## 527 howarfr01 TRUE FALSE ## 528 howelja01 TRUE FALSE ## 529 hoytwa01 TRUE FALSE ## 530 hubbeca01 TRUE FALSE ## 531 hudliwi01 TRUE FALSE ## 532 hugheto01 TRUE FALSE ## 533 hunteca01 TRUE FALSE ## 534 hurstbr01 TRUE FALSE ## 535 incavpe01 TRUE FALSE ## 536 jacksda02 TRUE FALSE ## 537 jacksda03 TRUE FALSE ## 538 jacksgr01 TRUE FALSE ## 539 jacksla01 TRUE FALSE ## 540 jacksmi02 TRUE FALSE ## 541 jacksre01 TRUE FALSE ## 542 jackstr01 TRUE FALSE ## 543 jacobba01 TRUE FALSE ## 544 jamiech01 TRUE FALSE ## 545 jarvike01 TRUE FALSE ## 546 javiest01 TRUE FALSE ## 547 jeffegr01 TRUE FALSE ## 548 jenkife01 TRUE FALSE ## 549 jennihu01 TRUE FALSE ## 550 johnscl01 TRUE FALSE ## 551 johnsde01 TRUE FALSE ## 552 johnsja01 TRUE FALSE ## 553 johnske02 TRUE FALSE ## 554 johnsla03 TRUE FALSE ## 555 johnsra05 TRUE FALSE ## 556 johnssi01 TRUE FALSE ## 557 johnssy01 TRUE FALSE ## 558 johnswa01 TRUE FALSE ## 559 johnto01 TRUE FALSE ## 560 jonesch01 TRUE FALSE ## 561 jonesda01 TRUE FALSE ## 562 jonesdo01 TRUE FALSE ## 563 jonesfi01 TRUE FALSE ## 564 jonessa01 TRUE FALSE ## 565 jonesto02 TRUE FALSE ## 566 joneswi01 TRUE FALSE ## 567 joosted01 TRUE FALSE ## 568 jordabr01 TRUE FALSE ## 569 jorgemi01 TRUE FALSE ## 570 joynewa01 TRUE FALSE ## 571 judgejo01 TRUE FALSE ## 572 jurgebi01 TRUE FALSE ## 573 justida01 TRUE FALSE ## 574 kaatji01 TRUE FALSE ## 575 kalinal01 TRUE FALSE ## 576 keefeti01 TRUE FALSE ## 577 keelewi01 TRUE FALSE ## 578 kellejo01 TRUE FALSE ## 579 kellge01 TRUE FALSE ## 580 kellyge01 TRUE FALSE ## 581 kellyki01 TRUE FALSE ## 582 kellypa01 TRUE FALSE ## 583 kellyro01 TRUE FALSE ## 584 kennebo01 TRUE FALSE ## 585 kenneve01 TRUE FALSE ## 586 kentje01 TRUE FALSE ## 587 kernji01 TRUE FALSE ## 588 kessido01 TRUE FALSE ## 589 keyji01 TRUE FALSE ## 590 killeha01 TRUE FALSE ## 591 kingmda01 TRUE FALSE ## 592 kirkped01 TRUE FALSE ## 593 kisonbr01 TRUE FALSE ## 594 kittrma01 TRUE FALSE ## 595 kleinch01 TRUE FALSE ## 596 kleskry01 TRUE FALSE ## 597 klinero01 TRUE FALSE ## 598 klippjo01 TRUE FALSE ## 599 kluszte01 TRUE FALSE ## 600 kneppbo01 TRUE FALSE ## 601 knowlda01 TRUE FALSE ## 602 koneted01 TRUE FALSE ## 603 koosmje01 TRUE FALSE ## 604 kraneed01 TRUE FALSE ## 605 kressre01 TRUE FALSE ## 606 kreutch01 TRUE FALSE ## 607 kruegbi01 TRUE FALSE ## 608 kuennha01 TRUE FALSE ## 609 kuheljo01 TRUE FALSE ## 610 kuzavbo01 TRUE FALSE ## 611 labincl01 TRUE FALSE ## 612 lacyle01 TRUE FALSE ## 613 lajoina01 TRUE FALSE ## 614 lampde01 TRUE FALSE ## 615 landrho01 TRUE FALSE ## 616 langsma01 TRUE FALSE ## 617 laniema01 TRUE FALSE ## 618 lankfra01 TRUE FALSE ## 619 lansfca01 TRUE FALSE ## 620 lapoida01 TRUE FALSE ## 621 larkiba01 TRUE FALSE ## 622 larocda01 TRUE FALSE ## 623 larsedo01 TRUE FALSE ## 624 laryfr01 TRUE FALSE ## 625 laryly01 TRUE FALSE ## 626 lathaar01 TRUE FALSE ## 627 lauch01 TRUE FALSE ## 628 lawtoma02 TRUE FALSE ## 629 lawve01 TRUE FALSE ## 630 lazzeto01 TRUE FALSE ## 631 leachto01 TRUE FALSE ## 632 learyti01 TRUE FALSE ## 633 leebi02 TRUE FALSE ## 634 leeth01 TRUE FALSE ## 635 leibone01 TRUE FALSE ## 636 leiteal01 TRUE FALSE ## 637 lemonbo01 TRUE FALSE ## 638 lemonch01 TRUE FALSE ## 639 leonadu02 TRUE FALSE ## 640 leonaje01 TRUE FALSE ## 641 lewisda01 TRUE FALSE ## 642 leyriji01 TRUE FALSE ## 643 lindbpa01 TRUE FALSE ## 644 loaizes01 TRUE FALSE ## 645 lockmwh01 TRUE FALSE ## 646 loftoke01 TRUE FALSE ## 647 lolicmi01 TRUE FALSE ## 648 lollash01 TRUE FALSE ## 649 lombaer01 TRUE FALSE ## 650 lonboji01 TRUE FALSE ## 651 longhe01 TRUE FALSE ## 652 lopesda01 TRUE FALSE ## 653 lopezal01 TRUE FALSE ## 654 lopezja01 TRUE FALSE ## 655 lowebo01 TRUE FALSE ## 656 lowenjo01 TRUE FALSE ## 657 lowrepe01 TRUE FALSE ## 658 lucasre01 TRUE FALSE ## 659 lummi01 TRUE FALSE ## 660 luquedo01 TRUE FALSE ## 661 luzingr01 TRUE FALSE ## 662 lylesp01 TRUE FALSE ## 663 lynnfr01 TRUE FALSE ## 664 lyonste01 TRUE FALSE ## 665 mabryjo01 TRUE FALSE ## 666 macfada01 TRUE FALSE ## 667 maddoga01 TRUE FALSE ## 668 maddugr01 TRUE FALSE ## 669 maddumi01 TRUE FALSE ## 670 madlobi01 TRUE FALSE ## 671 magadda01 TRUE FALSE ## 672 mageesh01 TRUE FALSE ## 673 majesha01 TRUE FALSE ## 674 maldoca01 TRUE FALSE ## 675 mancugu01 TRUE FALSE ## 676 mannle01 TRUE FALSE ## 677 mantlmi01 TRUE TRUE ## 678 manushe01 TRUE FALSE ## 679 maranra01 TRUE FALSE ## 680 marbefi01 TRUE FALSE ## 681 maricju01 TRUE FALSE ## 682 marquru01 TRUE FALSE ## 683 marshmi01 TRUE FALSE ## 684 martibu01 TRUE FALSE ## 685 martida01 TRUE FALSE ## 686 martide01 TRUE FALSE ## 687 martied01 TRUE FALSE ## 688 martipe02 TRUE FALSE ## 689 martiti01 TRUE FALSE ## 690 martiti02 TRUE FALSE ## 691 masiph01 TRUE FALSE ## 692 mastewa02 TRUE FALSE ## 693 mathebo01 TRUE FALSE ## 694 mathech01 TRUE FALSE ## 695 matheed01 TRUE FALSE ## 696 matthga01 TRUE FALSE ## 697 maulal01 TRUE FALSE ## 698 maxvida01 TRUE FALSE ## 699 maxwech01 TRUE FALSE ## 700 maybejo01 TRUE FALSE ## 701 mayele01 TRUE FALSE ## 702 mayle01 TRUE FALSE ## 703 maymi01 TRUE FALSE ## 704 maynebr01 TRUE FALSE ## 705 mayru01 TRUE FALSE ## 706 maysca01 TRUE FALSE ## 707 mayswi01 TRUE TRUE ## 708 mazerbi01 TRUE FALSE ## 709 mazzile01 TRUE FALSE ## 710 mcauldi01 TRUE FALSE ## 711 mcbrige01 TRUE FALSE ## 712 mccarti01 TRUE FALSE ## 713 mcclubo01 TRUE FALSE ## 714 mccormi03 TRUE FALSE ## 715 mccovwi01 TRUE FALSE ## 716 mcculcl01 TRUE FALSE ## 717 mcdanli01 TRUE FALSE ## 718 mcdowsa01 TRUE FALSE ## 719 mcelrch01 TRUE FALSE ## 720 mcfared01 TRUE FALSE ## 721 mcgeewi01 TRUE FALSE ## 722 mcgrajo01 TRUE FALSE ## 723 mcgratu01 TRUE FALSE ## 724 mcgrifr01 TRUE FALSE ## 725 mcguide01 TRUE FALSE ## 726 mcgwima01 TRUE TRUE ## 727 mcinnst01 TRUE FALSE ## 728 mclemma01 TRUE FALSE ## 729 mclisca01 TRUE FALSE ## 730 mcmahdo02 TRUE FALSE ## 731 mcmanma01 TRUE FALSE ## 732 mcmilro01 TRUE FALSE ## 733 mcmulke01 TRUE FALSE ## 734 mcnaier01 TRUE FALSE ## 735 mcphebi01 TRUE FALSE ## 736 mcraeha01 TRUE FALSE ## 737 mcwilla01 TRUE FALSE ## 738 meadole01 TRUE FALSE ## 739 medwijo01 TRUE FALSE ## 740 merceor01 TRUE FALSE ## 741 merckke01 TRUE FALSE ## 742 merklfr01 TRUE FALSE ## 743 mesajo01 TRUE FALSE ## 744 micelda01 TRUE FALSE ## 745 michaca01 TRUE FALSE ## 746 miksied01 TRUE FALSE ## 747 milancl01 TRUE FALSE ## 748 millebi02 TRUE FALSE ## 749 millebo04 TRUE FALSE ## 750 milleri01 TRUE FALSE ## 751 millest01 TRUE FALSE ## 752 minchdo01 TRUE FALSE ## 753 minosmi01 TRUE FALSE ## 754 mintogr01 TRUE FALSE ## 755 mitchcl01 TRUE FALSE ## 756 mitchke01 TRUE FALSE ## 757 mizejo01 TRUE TRUE ## 758 mogrige01 TRUE FALSE ## 759 molitpa01 TRUE FALSE ## 760 mondari01 TRUE FALSE ## 761 mondera01 TRUE FALSE ## 762 moneydo01 TRUE FALSE ## 763 montawi01 TRUE FALSE ## 764 moorech02 TRUE FALSE ## 765 mooreea01 TRUE FALSE ## 766 moorege03 TRUE FALSE ## 767 moralje01 TRUE FALSE ## 768 morgajo02 TRUE FALSE ## 769 morgami01 TRUE FALSE ## 770 morrija02 TRUE FALSE ## 771 morriji01 TRUE FALSE ## 772 morrijo01 TRUE FALSE ## 773 moseswa01 TRUE FALSE ## 774 mossle01 TRUE FALSE ## 775 motama01 TRUE FALSE ## 776 moyerja01 TRUE FALSE ## 777 muellra01 TRUE FALSE ## 778 mulhote01 TRUE FALSE ## 779 mullato01 TRUE FALSE ## 780 mullige01 TRUE FALSE ## 781 mullira01 TRUE FALSE ## 782 mumphje01 TRUE FALSE ## 783 murcebo01 TRUE FALSE ## 784 murphda02 TRUE FALSE ## 785 murphda05 TRUE FALSE ## 786 murphto02 TRUE FALSE ## 787 murrada01 TRUE FALSE ## 788 murraed02 TRUE FALSE ## 789 musiast01 TRUE FALSE ## 790 mussimi01 TRUE FALSE ## 791 myattgl01 TRUE FALSE ## 792 myerbu01 TRUE FALSE ## 793 myersgr01 TRUE FALSE ## 794 myershy01 TRUE FALSE ## 795 myersmi01 TRUE FALSE ## 796 myersra01 TRUE FALSE ## 797 nashbi01 TRUE FALSE ## 798 neaglde01 TRUE FALSE ## 799 nehfar01 TRUE FALSE ## 800 nelsoca01 TRUE FALSE ## 801 nelsoje01 TRUE FALSE ## 802 nettlgr01 TRUE FALSE ## 803 nevinph01 TRUE FALSE ## 804 newhoha01 TRUE FALSE ## 805 newsobo01 TRUE FALSE ## 806 nichobi01 TRUE FALSE ## 807 nichoki01 TRUE FALSE ## 808 niekrjo01 TRUE FALSE ## 809 niekrph01 TRUE FALSE ## 810 niemabo01 TRUE FALSE ## 811 nixonot01 TRUE FALSE ## 812 norenir01 TRUE FALSE ## 813 normafr01 TRUE FALSE ## 814 northro01 TRUE FALSE ## 815 nunezed01 TRUE FALSE ## 816 nuxhajo01 TRUE FALSE ## 817 oberkke01 TRUE FALSE ## 818 obriech01 TRUE FALSE ## 819 oconnja01 TRUE FALSE ## 820 odombl01 TRUE FALSE ## 821 oeschjo01 TRUE FALSE ## 822 ofarrbo01 TRUE FALSE ## 823 offerjo01 TRUE FALSE ## 824 oglivbe01 TRUE FALSE ## 825 ojedabo01 TRUE FALSE ## 826 olerujo01 TRUE FALSE ## 827 olivaom01 TRUE FALSE ## 828 olivato01 TRUE FALSE ## 829 oliveal01 TRUE FALSE ## 830 oliveda02 TRUE FALSE ## 831 olivejo01 TRUE FALSE ## 832 olsongr01 TRUE FALSE ## 833 olsoniv01 TRUE FALSE ## 834 oneilpa01 TRUE FALSE ## 835 oneilst01 TRUE FALSE ## 836 oroscje01 TRUE FALSE ## 837 orourji01 TRUE FALSE ## 838 ortajo01 TRUE FALSE ## 839 orthal01 TRUE FALSE ## 840 osteecl01 TRUE FALSE ## 841 osterfr01 TRUE FALSE ## 842 otisam01 TRUE FALSE ## 843 ottme01 TRUE FALSE ## 844 pacioto01 TRUE FALSE ## 845 pafkoan01 TRUE FALSE ## 846 paganjo01 TRUE FALSE ## 847 palmede01 TRUE FALSE ## 848 palmeji01 TRUE FALSE ## 849 palmera01 TRUE FALSE ## 850 pappami01 TRUE FALSE ## 851 parenma01 TRUE FALSE ## 852 parkch01 TRUE FALSE ## 853 parkeda01 TRUE FALSE ## 854 parrila01 TRUE FALSE ## 855 parrila02 TRUE FALSE ## 856 pascuca02 TRUE FALSE ## 857 paskedo01 TRUE FALSE ## 858 peckiro01 TRUE FALSE ## 859 peitzhe01 TRUE FALSE ## 860 penaal01 TRUE FALSE ## 861 penaor01 TRUE FALSE ## 862 penato01 TRUE FALSE ## 863 pendlte01 TRUE FALSE ## 864 pennohe01 TRUE FALSE ## 865 perezne01 TRUE FALSE ## 866 perezto01 TRUE FALSE ## 867 perkicy01 TRUE FALSE ## 868 perraro01 TRUE FALSE ## 869 perryga01 TRUE FALSE ## 870 perryji01 TRUE FALSE ## 871 petryda01 TRUE FALSE ## 872 pfefffr01 TRUE FALSE ## 873 pfeffje01 TRUE FALSE ## 874 phillda01 TRUE FALSE ## 875 phillto02 TRUE FALSE ## 876 piazzmi01 TRUE FALSE ## 877 picinva01 TRUE FALSE ## 878 piercbi02 TRUE FALSE ## 879 piersji01 TRUE FALSE ## 880 pinielo01 TRUE FALSE ## 881 pinsova01 TRUE FALSE ## 882 pippwa01 TRUE FALSE ## 883 pizarju01 TRUE FALSE ## 884 planked01 TRUE FALSE ## 885 plesada01 TRUE FALSE ## 886 plunker01 TRUE FALSE ## 887 podrejo01 TRUE FALSE ## 888 polleho01 TRUE FALSE ## 889 polonlu01 TRUE FALSE ## 890 pooleji02 TRUE FALSE ## 891 portebo01 TRUE FALSE ## 892 porteda02 TRUE FALSE ## 893 portuma01 TRUE FALSE ## 894 postwa01 TRUE FALSE ## 895 pottene01 TRUE FALSE ## 896 powelbo01 TRUE FALSE ## 897 powelja01 TRUE FALSE ## 898 powerte01 TRUE FALSE ## 899 powervi01 TRUE FALSE ## 900 prattto02 TRUE FALSE ## 901 princto01 TRUE FALSE ## 902 puhlte01 TRUE FALSE ## 903 purcebl01 TRUE FALSE ## 904 quantpa01 TRUE FALSE ## 905 quinnja01 TRUE FALSE ## 906 quinnjo02 TRUE FALSE ## 907 quirkja01 TRUE FALSE ## 908 raffeke01 TRUE FALSE ## 909 raganpa01 TRUE FALSE ## 910 raineti01 TRUE FALSE ## 911 ramirma02 TRUE FALSE ## 912 ramospe01 TRUE FALSE ## 913 randowi01 TRUE FALSE ## 914 rasmude01 TRUE FALSE ## 915 rawlijo01 TRUE FALSE ## 916 readyra01 TRUE FALSE ## 917 reardje01 TRUE FALSE ## 918 reedje02 TRUE FALSE ## 919 reedri01 TRUE FALSE ## 920 reedro01 TRUE FALSE ## 921 reedst01 TRUE FALSE ## 922 reesepe01 TRUE FALSE ## 923 reganph01 TRUE FALSE ## 924 remlimi01 TRUE FALSE ## 925 renkost01 TRUE FALSE ## 926 reuscri01 TRUE FALSE ## 927 reussje01 TRUE FALSE ## 928 reynocr01 TRUE FALSE ## 929 rhodear01 TRUE FALSE ## 930 rhoderi01 TRUE FALSE ## 931 ricede01 TRUE FALSE ## 932 riceji01 TRUE FALSE ## 933 ricesa01 TRUE FALSE ## 934 richaha01 TRUE FALSE ## 935 richepe01 TRUE FALSE ## 936 righeda01 TRUE FALSE ## 937 ripkeca01 TRUE FALSE ## 938 rivermi01 TRUE FALSE ## 939 rixeyep01 TRUE FALSE ## 940 roberda05 TRUE FALSE ## 941 roberro01 TRUE FALSE ## 942 robinbi02 TRUE FALSE ## 943 robinbr01 TRUE FALSE ## 944 robindo01 TRUE FALSE ## 945 robined01 TRUE FALSE ## 946 robinfr02 TRUE FALSE ## 947 robinwi01 TRUE FALSE ## 948 rodriau01 TRUE FALSE ## 949 rodriiv01 TRUE FALSE ## 950 rogerke01 TRUE FALSE ## 951 rojasco01 TRUE FALSE ## 952 roofph01 TRUE FALSE ## 953 rootch01 TRUE FALSE ## 954 rosepe01 TRUE FALSE ## 955 roushed01 TRUE FALSE ## 956 rowesc01 TRUE FALSE ## 957 roystje01 TRUE FALSE ## 958 rudijo01 TRUE FALSE ## 959 ruelmu01 TRUE FALSE ## 960 ruffire01 TRUE FALSE ## 961 russebi01 TRUE FALSE ## 962 russeja01 TRUE FALSE ## 963 russeje01 TRUE FALSE ## 964 ruthba01 TRUE TRUE ## 965 ruthvdi01 TRUE FALSE ## 966 ryanji01 TRUE FALSE ## 967 ryanno01 TRUE FALSE ## 968 saberbr01 TRUE FALSE ## 969 sadecra01 TRUE FALSE ## 970 sallesl01 TRUE FALSE ## 971 samueju01 TRUE FALSE ## 972 sanchre01 TRUE FALSE ## 973 sandbry01 TRUE FALSE ## 974 sandere02 TRUE FALSE ## 975 sandesc01 TRUE FALSE ## 976 santibe01 TRUE FALSE ## 977 santoro01 TRUE FALSE ## 978 sauerha01 TRUE FALSE ## 979 schaege01 TRUE FALSE ## 980 schalra01 TRUE FALSE ## 981 schanwa01 TRUE FALSE ## 982 schatda01 TRUE FALSE ## 983 schilcu01 TRUE FALSE ## 984 schmija01 TRUE FALSE ## 985 schmijo01 TRUE FALSE ## 986 schmimi01 TRUE FALSE ## 987 schoere01 TRUE FALSE ## 988 schofdi01 TRUE FALSE ## 989 schofdi02 TRUE FALSE ## 990 schreos01 TRUE FALSE ## 991 schulfr01 TRUE FALSE ## 992 scottev01 TRUE FALSE ## 993 scottge02 TRUE FALSE ## 994 seaneru01 TRUE FALSE ## 995 seaveto01 TRUE FALSE ## 996 seguida01 TRUE FALSE ## 997 seguidi01 TRUE FALSE ## 998 seleaa01 TRUE FALSE ## 999 seminan01 TRUE FALSE ## 1000 servisc01 TRUE FALSE ## 1001 severha01 TRUE FALSE ## 1002 sewellu01 TRUE FALSE ## 1003 seymocy01 TRUE FALSE ## 1004 shaffor01 TRUE FALSE ## 1005 shantbo01 TRUE FALSE ## 1006 shawbo01 TRUE FALSE ## 1007 shawkbo01 TRUE FALSE ## 1008 sheckji01 TRUE FALSE ## 1009 sheffga01 TRUE FALSE ## 1010 sherdbi01 TRUE FALSE ## 1011 shortch02 TRUE FALSE ## 1012 shouncl01 TRUE FALSE ## 1013 siebeso01 TRUE FALSE ## 1014 sierrru01 TRUE FALSE ## 1015 sievero01 TRUE FALSE ## 1016 simmoal01 TRUE FALSE ## 1017 simmocu01 TRUE FALSE ## 1018 simmote01 TRUE FALSE ## 1019 singebi01 TRUE FALSE ## 1020 singlke01 TRUE FALSE ## 1021 sislege01 TRUE FALSE ## 1022 skowrbi01 TRUE FALSE ## 1023 slatoji01 TRUE FALSE ## 1024 slaugdo01 TRUE FALSE ## 1025 slaugen01 TRUE FALSE ## 1026 smallro02 TRUE FALSE ## 1027 smithbo02 TRUE FALSE ## 1028 smithea02 TRUE FALSE ## 1029 smithel01 TRUE FALSE ## 1030 smithge01 TRUE FALSE ## 1031 smithja03 TRUE FALSE ## 1032 smithle02 TRUE FALSE ## 1033 smithlo01 TRUE FALSE ## 1034 smithoz01 TRUE FALSE ## 1035 smithpo01 TRUE FALSE ## 1036 smithre06 TRUE FALSE ## 1037 smithsh01 TRUE FALSE ## 1038 smithza01 TRUE FALSE ## 1039 smoltjo01 TRUE FALSE ## 1040 snidedu01 TRUE FALSE ## 1041 snowjt01 TRUE FALSE ## 1042 snydefr01 TRUE FALSE ## 1043 snydepo01 TRUE FALSE ## 1044 sojolu01 TRUE FALSE ## 1045 sosasa01 TRUE TRUE ## 1046 spahnwa01 TRUE FALSE ## 1047 speaktr01 TRUE FALSE ## 1048 speiech01 TRUE FALSE ## 1049 spencji01 TRUE FALSE ## 1050 spilmha01 TRUE FALSE ## 1051 splitpa01 TRUE FALSE ## 1052 sprinru01 TRUE FALSE ## 1053 staintu01 TRUE FALSE ## 1054 stairma01 TRUE FALSE ## 1055 stalege01 TRUE FALSE ## 1056 stanlfr01 TRUE FALSE ## 1057 stanlmi01 TRUE FALSE ## 1058 stanlmi02 TRUE FALSE ## 1059 stantmi02 TRUE FALSE ## 1060 stargwi01 TRUE FALSE ## 1061 startjo01 TRUE FALSE ## 1062 staubru01 TRUE FALSE ## 1063 stengca01 TRUE FALSE ## 1064 stephve01 TRUE FALSE ## 1065 stewada01 TRUE FALSE ## 1066 stiebda01 TRUE FALSE ## 1067 stinnke01 TRUE FALSE ## 1068 stobbch01 TRUE FALSE ## 1069 stottto01 TRUE FALSE ## 1070 stoveha01 TRUE FALSE ## 1071 strawda01 TRUE FALSE ## 1072 strunam01 TRUE FALSE ## 1073 sturdto01 TRUE FALSE ## 1074 sullibi03 TRUE FALSE ## 1075 sundbji01 TRUE FALSE ## 1076 suppaje01 TRUE FALSE ## 1077 surhobj01 TRUE FALSE ## 1078 sutclri01 TRUE FALSE ## 1079 suttodo01 TRUE FALSE ## 1080 suttoez01 TRUE FALSE ## 1081 sweenma01 TRUE FALSE ## 1082 swiftbo01 TRUE FALSE ## 1083 swindgr01 TRUE FALSE ## 1084 tananfr01 TRUE FALSE ## 1085 tanneje01 TRUE FALSE ## 1086 tapanke01 TRUE FALSE ## 1087 tartada01 TRUE FALSE ## 1088 tavarju01 TRUE FALSE ## 1089 tayloto02 TRUE FALSE ## 1090 tayloza02 TRUE FALSE ## 1091 tebbebi01 TRUE FALSE ## 1092 tekulke01 TRUE FALSE ## 1093 templga01 TRUE FALSE ## 1094 tenacge01 TRUE FALSE ## 1095 tennefr02 TRUE FALSE ## 1096 terryad01 TRUE FALSE ## 1097 terryra01 TRUE FALSE ## 1098 theveto01 TRUE FALSE ## 1099 thomade01 TRUE FALSE ## 1100 thomafr03 TRUE FALSE ## 1101 thomafr04 TRUE FALSE ## 1102 thomage01 TRUE FALSE ## 1103 thomago01 TRUE FALSE ## 1104 thomato02 TRUE FALSE ## 1105 thomeji01 TRUE TRUE ## 1106 thompmi02 TRUE FALSE ## 1107 thompsa01 TRUE FALSE ## 1108 thomsbo01 TRUE FALSE ## 1109 thondi01 TRUE FALSE ## 1110 thornan01 TRUE FALSE ## 1111 tiantlu01 TRUE FALSE ## 1112 tidrodi01 TRUE FALSE ## 1113 timlimi01 TRUE FALSE ## 1114 tinkejo01 TRUE FALSE ## 1115 torgeea01 TRUE FALSE ## 1116 torrejo01 TRUE FALSE ## 1117 torremi01 TRUE FALSE ## 1118 trachst01 TRUE FALSE ## 1119 trammal01 TRUE FALSE ## 1120 traynpi01 TRUE FALSE ## 1121 trevial01 TRUE FALSE ## 1122 trillma01 TRUE FALSE ## 1123 troutdi01 TRUE FALSE ## 1124 truckvi01 TRUE FALSE ## 1125 tucketo01 TRUE FALSE ## 1126 turnete01 TRUE FALSE ## 1127 uhlege01 TRUE FALSE ## 1128 unserde01 TRUE FALSE ## 1129 valdeis01 TRUE FALSE ## 1130 valenfe01 TRUE FALSE ## 1131 valenjo03 TRUE FALSE ## 1132 valoel01 TRUE FALSE ## 1133 vanceda01 TRUE FALSE ## 1134 vandejo02 TRUE FALSE ## 1135 vanhage01 TRUE FALSE ## 1136 vaughgr01 TRUE FALSE ## 1137 veachbo01 TRUE FALSE ## 1138 velarra01 TRUE FALSE ## 1139 venturo01 TRUE FALSE ## 1140 vernomi01 TRUE FALSE ## 1141 villoro01 TRUE FALSE ## 1142 violafr01 TRUE FALSE ## 1143 vizcajo01 TRUE FALSE ## 1144 vizquom01 TRUE FALSE ## 1145 wagneha01 TRUE FALSE ## 1146 wagneho01 TRUE FALSE ## 1147 wakefti01 TRUE FALSE ## 1148 walberu01 TRUE FALSE ## 1149 walkedi02 TRUE FALSE ## 1150 walkege02 TRUE FALSE ## 1151 walkela01 TRUE FALSE ## 1152 walketo04 TRUE FALSE ## 1153 wallabo01 TRUE FALSE ## 1154 wallati01 TRUE FALSE ## 1155 wallide01 TRUE FALSE ## 1156 waltebu01 TRUE FALSE ## 1157 wanerll01 TRUE FALSE ## 1158 wanerpa01 TRUE FALSE ## 1159 wardjo01 TRUE FALSE ## 1160 warnejo01 TRUE FALSE ## 1161 warnelo01 TRUE FALSE ## 1162 washicl01 TRUE FALSE ## 1163 watsobo01 TRUE FALSE ## 1164 weathda01 TRUE FALSE ## 1165 webstmi01 TRUE FALSE ## 1166 wehmehe01 TRUE FALSE ## 1167 welchbo01 TRUE FALSE ## 1168 wellsda01 TRUE FALSE ## 1169 wertzvi01 TRUE FALSE ## 1170 westsa01 TRUE FALSE ## 1171 weyhigu01 TRUE FALSE ## 1172 wheatza01 TRUE FALSE ## 1173 whitalo01 TRUE FALSE ## 1174 whitede01 TRUE FALSE ## 1175 whitede03 TRUE FALSE ## 1176 whiteea01 TRUE FALSE ## 1177 whitefr01 TRUE FALSE ## 1178 whitema01 TRUE FALSE ## 1179 whiteri01 TRUE FALSE ## 1180 whitero01 TRUE FALSE ## 1181 whitero02 TRUE FALSE ## 1182 whitsed01 TRUE FALSE ## 1183 whitter01 TRUE FALSE ## 1184 wickmbo01 TRUE FALSE ## 1185 wightbi01 TRUE FALSE ## 1186 wilcomi01 TRUE FALSE ## 1187 wilheho01 TRUE FALSE ## 1188 wilkiri01 TRUE FALSE ## 1189 willibe02 TRUE FALSE ## 1190 willibi01 TRUE FALSE ## 1191 willicy01 TRUE FALSE ## 1192 willidi02 TRUE FALSE ## 1193 willige02 TRUE FALSE ## 1194 willima04 TRUE FALSE ## 1195 willist02 TRUE FALSE ## 1196 willite01 TRUE FALSE ## 1197 williwo02 TRUE FALSE ## 1198 willsma01 TRUE FALSE ## 1199 wilsoar01 TRUE FALSE ## 1200 wilsoji01 TRUE FALSE ## 1201 wilsowi02 TRUE FALSE ## 1202 winfida01 TRUE FALSE ## 1203 wingoiv01 TRUE FALSE ## 1204 wiseri01 TRUE FALSE ## 1205 witasja01 TRUE FALSE ## 1206 wittbo01 TRUE FALSE ## 1207 wohlfji01 TRUE FALSE ## 1208 womacto01 TRUE FALSE ## 1209 woodge01 TRUE FALSE ## 1210 woodlge01 TRUE FALSE ## 1211 woodwi01 TRUE FALSE ## 1212 worreti01 TRUE FALSE ## 1213 worthal01 TRUE FALSE ## 1214 wyattwh01 TRUE FALSE ## 1215 wynnea01 TRUE FALSE ## 1216 wynnji01 TRUE FALSE ## 1217 yastrca01 TRUE FALSE ## 1218 yeagest01 TRUE FALSE ## 1219 yorkto01 TRUE FALSE ## 1220 yosted01 TRUE FALSE ## 1221 youngcy01 TRUE FALSE ## 1222 younger01 TRUE FALSE ## 1223 youngjo02 TRUE FALSE ## 1224 yountro01 TRUE FALSE ## 1225 zachato01 TRUE FALSE ## 1226 zaungr01 TRUE FALSE ## 1227 zeileto01 TRUE FALSE ## 1228 zimmech01 TRUE FALSE More plyr Functions There are even more functions that we have not considered in this package. For example, we have an mapply() version for plyr. mdply(cbind(mean = 1:5, sd = 1:5), rnorm, n = 5) ## mean sd V1 V2 V3 V4 V5 ## 1 1 1 0.3068252 2.597985 1.6701004 2.478022 1.146168 ## 2 2 2 1.9081973 2.540262 4.0358842 1.403136 1.174000 ## 3 3 3 4.5592248 0.308029 0.2552031 2.892366 1.389544 ## 4 4 4 4.2569431 3.088500 8.6408356 7.598323 5.176289 ## 5 5 5 -0.1205350 6.274319 5.8327707 1.981088 5.963103 14.8 Comparing Base R, Loops, plyr # Plyr way system.time(ddply(baseball, &quot;id&quot;, summarize, length(year))) ## user system elapsed ## 0.242 0.001 0.243 # Apply method way system.time(tapply(baseball$year, baseball$id, function(x) length(x))) ## user system elapsed ## 0.005 0.000 0.005 # Loop way system.time({ for(i in unique(baseball$id)){ length(which(baseball$id == i)) } }) ## user system elapsed ## 0.193 0.039 0.232 References "],["references.html", "References", " References "]]
