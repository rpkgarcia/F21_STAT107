# More On Objects 

```{r, echo = F}
library(xtable)
options(xtable.comment = FALSE)
```

### Factors {-} 

In real-world problems, you often encounter data that can be classified in categories. For example, suppose a survey was conducted of a group of seven individuals, who were asked to identify their hair color and gender.

```{r, echo = F, results = 'asis'}
name = c("Amy", "Bob", "Eve", "Kim", "Max", "Ray", "Sam")
hair = c("Blonde", "Black", "Black", "Red", "Blonde", "Brown", "Black")
gender = c("Female", "Male", "Female", "Female", "Male", "Male", "Male")

catagorical = cbind(name, hair, gender)
colnames(catagorical) = c("Name", "Hair Color", "Gender")

print(xtable(catagorical), include.rownames = F, type = "html")

```


Here, the hair color and gender are the examples of categorical data. To store such categorical data, `R` has a special data structure called factors. A factor is an ordered collection of items. The different values that the factor can take are called levels. In `R`, you can create a factor with the `factor()` function. 

```{r}
hcolors = c("Blonde", "Black", "Black", "Red", "Blonde", "Brown", "Black")
f = factor(hcolors)
f
```




A factor looks like a vector, but it has special properties. Levels are one of them. Notice that when you print the factor, `R` displays the distinct levels below the factor. `R` keeps track of all the possible values in a vector, and each value is called a level of the associated factor.The `levels()` function shows all the levels from a factor.

```{r}
gender = c("Female", "Male", "Female", "Female", "Male", "Male", "Male")
f = factor(gender)
levels(f)
f
```


If your vector contains only a subset of all the possible levels, then R will have an incomplete picture of the possible levels. Consider the following example of a vector consisting of directions:

```{r}
directions = c("North", "West", "North", "East", "North", "West", "East")
f = factor(directions)
f
```

Notice that the levels of your new factor do not contain the value “South”. So, `R` thinks that North, West, and East are the only possible levels. However, in practice, it makes sense to have all the possible directions as levels of your factor. To add all the possible levels explicitly, you specify the `levels` argument of the function `factor()`.

```{r}
directions = c("North", "West", "North", "East", "North", "West", "East")
f = factor(directions,
            levels = c("North", "East", "South", "West"))
f
```

R lets you assign abbreviated names for the levels. You can do this by specifying the `labels` argument of `factor()`.

```{r}
directions = c("North", "West", "South", "East", "West", "North", "South")
f = factor(directions,
            levels = c("North", "East", "South", "West"),
            labels = c("N", "E", "S", "W"))
f
```

Sometimes data has some kind of natural order between elements. For example, sports analysts use a three-point scale to determine how well a sports team is competing: 

**loss < tie < win**.

In market research, it’s very common to use a five point scale to measure perceptions: 

**strongly disagree < disagree < neutral < agree < strongly agree**.

Such kind of data that is possible to place in order or scale is known as **Ordinal data**. In `R`, there is a special data type for ordinal data. This type is called ordered factors. To create an ordered factor, use the `factor()` function with the argument `ordered=TRUE`.  

```{r}
record = c("win", "tie", "loss", "tie", "loss", "win", "win")
f = factor(record, 
            ordered = TRUE)
f
```


You can also reverse the order of levels using the `rev()` function. 

```{r}
record = c("win", "tie", "loss", "tie", "loss", "win", "win")
f = factor(record, 
            ordered = TRUE, 
            levels = rev(levels(f)))
f

```


If you have no observations in one of the levels, you can drop it using the `droplevels()` function.

```{r}
record = c("win", "loss", "loss", "win", "loss", "win")
f = factor(record,
            levels = c("loss", "tie", "win"))

f

droplevels(f)

```

The `summary()` function will give you a quick overview of the contents of a factor.


```{r}
gender = c("Female", "Male", "Female", "Female", "Male", "Male", "Male")
f = factor(gender)
summary(f)
```

The function `table()` tabulates observations.


```{r}
table(f)
```



### Lists {-} 

A *list* is an array of objects. Unlike vectors and matrices, the objects can belong to different classes. Lists are useful for packaging together a set of related objects. We can create a list of objects in our workspace by using the `list()` function.

```{r}
lst = list(1, 2, 3)

# A list of characters
lst = list("red", "green", "blue")

# A list of mixed datatypes
lst = list(1, "abc", 1.23, TRUE)
```

The best way to understand the contents of a list is to use the structure function `str()`. It provides a compact display of the internal structure of a list.

```{r}
lst = list(1, "abc", 1.23, TRUE)
str(lst)
```


A list can contain sublists, which in turn can contain sublists themselves, and so on. This is known as *nested list* or *recursive vectors*.

```{r}
lst = list(1, 3, "abc", list("a","b","c"), TRUE)
str(lst)
```

There are two ways to extract elements from a list:

- Using `[[]]` gives you the element itself.
- Using `[]` gives you a list with the selected elements

You can use `[]` to extract either a single element or multiple elements from a list. However, the result will always be a list.

```{r}
# extract 2nd element
lst[2]

# extract 5th element
lst[5]

# select 1st, 3rd and 5th element
lst[c(1,3,5)]

# exclude 1st, 3rd and 5th element
lst[c(-1,-3,-5)]

```


You can use `[[]]` to extract only a single element from a list. Unlike `[]`, `[[]]` gives you the element itself.

```{r}
# extract 2nd element
lst[[2]]

# extract 5th element
lst[[5]]

```

You can’t use logical vectors or negative numbers as indices when using `[[]]`.  The difference between `[]` and `[[]]` is really important for lists, because `[[]]` returns the element itself while `[]` returns a list with the selected elements. The difference becomes clear when we inspect the structure of the output – one is a character and the other one is a list.

```{r}
lst = list("a","b","c","d","e","f")

class(lst[[1]])

class(lst[1])
```

Each list element can have a name. You can access individual element by specifying its name in double square brackets `[[]]` or use `$` operator.

```{r}
months = list(JAN=1, FEB=2, MAR=3, APR=4)

# extract element by its name
months[["MAR"]]


# same as above but using the $ operator
months$MAR


# extract multiple elements
months[c("JAN","APR")]


```

You can access individual items in a nested list by using the combination of `[[]]` or `$` operator and the `[]` operator.

```{r}
lst = list(item1 = 3.14,
            item2 = list(item2a = 5:10,
                         item2b = c("a","b","c")))

# preserve the output as a list
lst[[2]][1]


# same as above but simplify the output
lst[[2]][[1]]


# same as above with names
lst[["item2"]][["item2a"]]


# same as above with $ operator
lst$item2$item2a


# extract individual element
lst[[2]][[2]][3]


```

Modifying a list element is pretty straightforward. You use either the `[[]]` or the `$` to access that element, and simply assign a new value.

```{r}
# Modify 3rd list element
lst = list("a","b","c","d","e","f")
lst[[3]] = 1
str(lst)

```

You can modify components using `[]` as well, but you have to assign a list of components.

```{r}
# Modify 3rd list element using []
lst = list("a","b","c","d","e","f")
lst[3] = list(1)
str(lst)

```


Using `[]` allows you to modify more than one component at once.

```{r}
# Modify first three list elements
lst = list("a","b","c","d","e","f")
lst[1:3] = list(1,2,3)
str(lst)

```

You can use same method for modifying elements and adding new one. If the element is already present in the list, it is updated else, a new element is added to the list.

```{r}
# Add elements to a list
lst = list(1, 2, 3)
lst[[4]] = 4
str(lst)


```

By using `append()` method you can append one or more elements to the list.

```{r}
# Add more than one element to a list
lst = list(1, 2, 3)
lst = append(lst,c("a","b","c"))
str(lst)


```

To remove a list element, select it by position or by name, and then assign `NULL` to it.

```{r}
# Remove element from list
lst = list("a","b","c","d","e")
lst[[3]] = NULL
str(lst)
```

Using `[]`, you can delete more than one component at once.

```{r}
# Remove multiple elements at once
lst = list("a","b","c","d","e")
lst[1:4] = NULL
str(lst)
```

By using a logical vector, you can remove list elements based on the condition.

```{r}
# Remove all negative list elements
lst = list(-4,-3,-2,-1,0,1,2,3,4)
lst[lst <= 0] = NULL
str(lst)
```


The `c()` does a lot more than just creating vectors. It can be used to combine lists into a new list as well.

```{r}
lst1 = list("a","b","c")
lst2 = list(1,2,3)
lst = c(lst1, lst2)
str(lst)
```

Basic statistical functions work on vectors but not on lists. For example, you cannot directly compute the mean of list of numbers. In that case, you have to flatten the list into a vector using `unlist()` first and then compute the mean of the result.

```{r}
lst = list(5, 10, 15, 20, 25)
mean(unlist(lst))
```

To find the length of a list, use `length()` function.


```{r}
length(lst)
```
